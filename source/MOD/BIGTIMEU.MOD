IMPLEMENTATION MODULE BigTimeU;

  (* BigTimeU - Big Time Units.

       This procedure provides the routines to convert into and out of time
       units that are absolute off some base of time.  That is, # of seconds
       since, say, 1980.

       Modification History -

       Jun 19, 1987  RSC  - First version.
       Aug. , 1987   AJL  - Modified to use KDay and KDate so that
                            the numbers really correspond to Julian
                            dates.  The BigTime is the number of
                            seconds since Feb. 29, 1980 12:00 am.
                            Julian Date = 2531959 + (Big / 86400).
                          - Changed the BigTimeArrays to local
                            from global to support reentrant code.

    15-Mar-89 RSC           If the date is outside TimeLine's range of
                            March 1, 1980 through Dec 31, 1999, set the
                            date to be just within the limits.
    14-Sep-89 KKC           Use TimeTable.FirstYear and TimeTable.FirstYear
                            + YearsOnFile as the lower and upper limit in
                            TimeToBigTime.
    30-Mar-90 RSC           Made Timeu to Timei/TimeForm conversions.
    15-Aug-90 RSC           Changed the scaling at the begining of
                            conversions to not scale for the calendar,
                            but for BigTime limitations only.
    20-Aug-90 RSC           Converted to LONGINTs.  Look for OBigTimeU
                            for the old format.
     3-Jul-91 PFG           Use calendar year limits as lower and upper
                            limits for BaseYear and LastYear.
     2-Aug-91 PFG           Although the rules for calling BigTimeToTime are
                            that the BigTime you pass in was generated by an
                            earlier call to TimeToBigTime, some schedule files
                            had been created containing BigTimes with years
                            outside of the calendar range.  This is now
                            checked for in BigTimeToTime.
  *)


FROM Timei      IMPORT
    (* TYPE *)      ATimeInfo,
    (* PROC *)      KDay, KDate;

FROM Timeu      IMPORT
    (* CONST  *)    CalendarBaseYear, YearsOnFile;




CONST


    (* Due to algorithmic limitations,
    
       BaseYear cannot be less than or equal to KDay's minimum.
       LastYear cannot be > 2^31 seconds after BaseYear.

       Since we use KDay/KDate, we must be sensitive to its limits.
       We also don't deal well with negative LONGINTs, especially in
       comparing two dates, so don't use more than 31 of the 32 bits.
    *)

(* 3-Jul-91 PFG   Use the calendar limits instead and initialize below.

       BaseYear     = 1981;          (* BigTime starts here. *)
       LastYear     = BaseYear + 65; (* And ends a little after here. *)
*)

        BaseYear    = CalendarBaseYear;
        LastYear    = CalendarBaseYear + YearsOnFile - 1;





  (* TimeToBigTime - Convert into BigTime units.

     Preconditions  - Year, Month, Day, Hour, Minute, Second must be set
                      to reasonable values.  Keeping with TimeU conventions,
                      'Month' Starts with 0 as January.

     Postconditions - BigTime is set to the internal big representation.
  *)

PROCEDURE TimeToBigTime(     Year,
                             Month,
                             Day,
                             Hour,
                             Minute,
                             Second    : CARDINAL;
                         VAR BigTime   : ABigTime );
VAR
    Days,
    Hours,
    Minutes,
    Seconds : LONGINT;
BEGIN
        (* RSC 15-Mar-89 If the date is outside TimeLine's max, default to be
                         within the limits.
        *)
    IF (Year > LastYear) THEN
        Year  := LastYear;
        Month := 11;
        Day   := 31;
    ELSIF (Year < BaseYear) THEN
        Year  := BaseYear;
        Month := 0;
        Day   := 1;
    END;

        (* 20-Aug-90 RSC Use LONGINTs rather than REALs.
        *)
    Days    :=                   VAL( LONGINT, KDay(Year,Month,Day) );
    Hours   := (Days    * 24L) + VAL( LONGINT, Hour   );
    Minutes := (Hours   * 60L) + VAL( LONGINT, Minute );
    Seconds := (Minutes * 60L) + VAL( LONGINT, Second );

    BigTime := ABigTime( Seconds );

END TimeToBigTime;






(* TimeInfoToBigTime

    Same as Time To Big Time, but using ATimeInfo rather than the
    discreet fields.
*)
PROCEDURE TimeInfoToBigTime(     TimeInfo    : ATimeInfo;
                             VAR BigTime     : ABigTime   );
BEGIN
    WITH TimeInfo DO
        TimeToBigTime( tiYear, tiMonth, tiDay, tiHour, tiMinute, tiSecond, BigTime );
    END;
END TimeInfoToBigTime;








  (* BigTimeToTime - Convert out of BigTime units.

     Preconditions  - BigTime is from a prior call to TimeToBigTime.

     Postconditions - Year, Month, Day, Hour, Minute, Second are returned.
  *)


PROCEDURE BigTimeToTime(     BigTime     : ABigTime;
                         VAR Year,
                             Month,
                             Day,
                             Hour,
                             Minute,
                             Second      : CARDINAL );
VAR
    Days,
    Hours,
    Minutes,
    Seconds : LONGINT;
BEGIN

        (* 20-Aug-90 RSC Use LONGINTs rather than REALs.
        *)
    Seconds := LONGINT( BigTime );
    Minutes := Seconds DIV 60L;
    Hours   := Minutes DIV 60L;
    Days    := Hours   DIV 24L;

    KDate( VAL(CARDINAL, Days),  Year, Month, Day );

        (* 2-Aug-91 PFG  If the date is outside TimeLine's max, default to be
                         within the limits.
        *)
    IF (Year > LastYear) THEN
        Year  := LastYear;
        Month := 11;
        Day   := 31;
    ELSIF (Year < BaseYear) THEN
        Year  := BaseYear;
        Month := 0;
        Day   := 1;
    END;

    Hour    := VAL(CARDINAL, Hours   MOD 24L );
    Minute  := VAL(CARDINAL, Minutes MOD 60L );
    Second  := VAL(CARDINAL, Seconds MOD 60L );

END BigTimeToTime;








(* BigTimeToTimeInfo

    Same as Big Time To Time, but using ATimeInfo rather than the
    discreet fields.
*)
PROCEDURE BigTimeToTimeInfo(     BigTime     : ABigTime;
                             VAR TimeInfo    : ATimeInfo   );
BEGIN
    WITH TimeInfo DO
        BigTimeToTime( BigTime, tiYear, tiMonth, tiDay, tiHour, tiMinute, tiSecond );
    END;
END BigTimeToTimeInfo;










(* Compare Big Times.

    Preconditions  - BigTime is from a prior call to TimeToBigTime.

    Returns <0 if A < B
            =0 if A = B
            >0 if A > B
*)
PROCEDURE CompareBigTimes(  A, B : ABigTime ) : INTEGER;
VAR
    i   : INTEGER;
BEGIN

    IF (LONGINT(A) > LONGINT(B)) THEN
        i := +1;
    ELSIF (LONGINT(A) < LONGINT(B)) THEN
        i := -1;
    ELSE
        i := 0;
    END;

    RETURN i;

END CompareBigTimes;



BEGIN

    TimeToBigTime(    0,  0,  0,  0,  0,  0, MINBIGTIME );
    TimeToBigTime( 9999, 11, 31, 23, 59, 59, MAXBIGTIME );

END BigTimeU.
