IMPLEMENTATION MODULE RunMenu2;

(*V1=DEBUG*)
(*V7=TRACE*)

    (****************************************************************)
    (*                                                              *)
    (*      RunMenu -- Put up a menu of possible items of           *)
    (*          the class indicated.  If one is picked, run it.     *)
    (*                                                              *)
    (*                                                              *)
    (****************************************************************)

    (*   MODIFICATION HISTORY:

         1/13/86   AJL  -- The processing of help requests has been
                           moved into the main loop.
                        -- Keycodes can now be generated by starting
                           an action with "{".
         5/8/86    AJL  -- Read the file only the first time.
         5/20/86   AJL  -- Add procedure FancyOverlaysMenu.
         5/11/87   AJL  -- Added hook for Chainer module.
                           The NAME section of any line whose class
                           is "+" will be sent to the Chainer module
                           procedure AddModuleName.
         8/13/87   AJL  -- Allow longer Descriptions in Init.
         9/12/87   AJL  -- We now call all overlays using the
                           CallOverlayWithContext procedure, and pass
                           the address of the action string.
         9/19/87   AJL  -- If the action string contains an "(", then
                           the context passed to the CallOverlayWithContext
                           will contain everything past that "(" to
                           a matching ")".
                        -- An @ command, with a non-null subject, will
                           use that subject as the prefix on the menu call.
         9/28/87   AJL  -- Do not add disabled menu items to a menu.
                        -- Store action strings in variable length heap
                           space.
        11/10/87   RSC  -- Increase size of largest action string.
                           Put text file reading into AsciiIO module (new).
        11/19/87   AJL  -- Added new action command, "<", which returns
                           an action string to the caller.
        11/20/87   AJL  -- Added substitutable parameters with the ?(...)
                           and %n syntax.  Each name within
                           ?(...) will cause a menu call.  The list of
                           values returned will be substituted for %1..%9.
                           Multiple ?(...) will assign values to successive
                           parameters.
        11/23/87   AJL  -- Added parameters in the call other menu
                           ("@") command.  These are parsed and substituted
                           for &1 through &9.
        12/02/87   AJL  -- Allow Esc from ?(...) menu.
                        -- Substitute % for %% and & for && when
                           substituting parameters.
         1/20/88   AJL  -- Allow a Class = "-" to suppress any action.
                           A crude comment.  Still requires format of
                           -,,,Comment. 
            ??     AJL  -- Store prompts in FlexStor. 
        2/20/88    AJL  -- When storing prompts into flexstor, only store
                           them when they are not empty lines, and 
                           round up their lengths to an even number. 
        8/16/88    RSC  -- Save space by making record var size.  Other minor
                           Speed/Size improvements.

                           NEW RESTRICTION:

                                OVERLAYS TO BE LOADED AT STARTUP MUST BE FIRST
                                IN THE FILE, AFTER ANY OPTIONAL COMMENTS.
                                NO OTHER LINES MAY BE FIRST!!

        11/3/88    RSC  -- Save stack space by allocating stuff from the heap.
                           Add a LowMemory Warning box.
        11/15/88   RSC  -- Back off from the change of 11/3.  When you run out
                           of heap space, you can't save the schedule.
        12/07/88   AJL  -- In ExtraFancyMenu, took many fields out of the
                           Context, put remainder into FlexStor.
                        -- Use a new procedure, ExtractObject, allowing us to
                           extract the overlay name from ActionString while
                           leaving the largest part of the string still in
                           ActionString.  This greatly reduces stack space.
                        -- Made MaxActionsLength 250.
                        -- Reduced size of AParm from 20 to 19.
                        -- Made NextAction in ExtraFancyMenu be AParm.
        2-Jan-89   RSC  -- Added references to StringsEqual() rather than Compare().
       10-Jan-89   RSC  -- changed Storage to Space.
        2-Feb-89   RSC  -- Changed params to ParseBal.
        3-Feb-89   RSC  -- Split out "InitMenu" from here.
                           Added "SpecialCharactors".
       20-Mar-89   AJL  -- If the prompt is NIL in PromptProc, don't crash.  
       22-May-89   KKC  -- Do not exit if OverlayPackage return FALSE in
                           ExtraFancyMenu
       05-Jun-89   KKC  -- Fixing bugs for Bug Report # 323
                           In ExtraFancyMenu, if GetParameters return an
                           nonzero Code but Sticky is on, do not return.
       19-Jul-89   RSC  -- Do not store the records in a list, but on the
                           phrases file for the class "TLWHAT".
                           Keep an index of items in memory for faster
                           access.  Keep a list of exceptions in FlexStor.
       23-Aug-89   RSC  -- Context areas were being allocated from FlexStor.
                           Changed these allocations from Slow FlexStor to
                           Meduium speed storage.
       11-Dec-89   RSC     Updated call to Menus for new MODAL parameter.
       08-Jan-89   RSC  - Removed unused code.
       15-Apr-91   RSC  - Update for new MenuWithPrompt code.
       30-Apr-91   RSC  - Stickyness still is not flawless after all this
                          time.  When a submenu (@SOUND) does things that
                          return a code, the stickyness was ignored.  I
                          patched this, but I'm not sure what OTHER
                          consequences this has (like ESC not always working?)
                          Likewise, Dispatch codes ({450+) seemed to
                          ignore stickyness.
       13-May-91   RSC    CurrentClassIndex was global.  Removed it.
       12-Jul-91   AJL    Revised ExtraFancyMenu to return strings, and
                          to take parameters allowing it to return to 
                          a submenu before presenting a choice.
    *)

    (*   The actions are controlled by the contents of the file
         TLWHAT.CFG.

         [Class],[Item Description],[Action],[Description]

         If there is only one item of the class, then the action will
         be taken immediately.

         Otherwise, a menu of [Item Description]s will be displayed, and
         the chosen action, if any, will be taken.

         If [Action] begins with "." (period) it is a call to Help.

         If [Action] begins with "@" it selects another class for
            additional menu selection.

         If [Action] begins with "{" it indicates that it is followed
            by a number, whose value is returned.

         If [Action] begins with "=" it indicates that it is followed
            by a number.  We call the dispatcher with this action
            number.

         An [Action] beginning with ">" is the name of an overlay file
            to call.

         An [Action] beginning with "<" will return the following
         characters to the caller.

         If [Action] ends with "+", the menu will be repeated after
         the action is taken.   (This is called being "sticky." )

         If a Name begins with "{", it may be followed by a number.
         The "{", the number and the following character will be removed.
         If the key code read from the keyboard matches this number,
         it will be as though that menu item were selected.

         The following are parameters that can be substituted during
         menu interpretation:

         &1 .. &5   Parameters supplied in a parenthesis in the Class
                    string are substituted into the ItemDescription and
                    Action of each item.

         %1 .. %5   These are parameters that can be obtained by a menu
                    call using the ?(CLASS) syntax.  If the menu identified
                    by the CLASS returns a string, parenthesized items
                    in it are substituted for these parameters.

         ?(Class)   calls a menu and returns a list of parameters.

        *)

FROM Boxes          IMPORT
    (* TYPE *)          ABoxType, ABoxAttribute,
    (* PROC *)          DrawBox;

FROM Codes          IMPORT
    (* TYPE *)          ACode, ASetOfCodes,
    (* PROC *)          SetCodeBits;

FROM CodeSets       IMPORT
    (* VAR *)           MenuCodeSet;

FROM Dialog         IMPORT
    (* PROC *)          Message, Error, FatalError, Barf,
                        ErrorPhrase;

IMPORT Dispatcher;

FROM FlexStor       IMPORT
    (* TYPE *)          AnExtHandle,      AnExtStoragePreference,
    (* PROC *)          CreateExtObjectWithSize,
                        DiscardExtObject, LockObjectArray,
                        LockObject,       ReleaseObject, 
                        ReleaseUnchangedObject;
 
FROM Helper         IMPORT
    (* TYPE *)          AScreenAction,
    (* PROC *)          GiveHelp;

FROM Kbio           IMPORT
    (* CONST *)         maxcol,
    (* TYPE *)          avidmode, ascreenx, ascreeny,
    (* PROC *)          PushCode;

FROM Keys           IMPORT
    (* CONST *)         DoIt, CancelKey;

FROM Layout         IMPORT
    (* VAR *)           GanttWStart, GanttWEnd;

FROM LStrings       IMPORT
    (* PROC *)          ConcatS, ConcatLS, SetString, StoC, SetLengthOf,
                        SubStr, Fill, StringsEqual, Remove, Copy, Search,
                        LengthOf, Insert, CtoS;

FROM MenuHelper     IMPORT
    (* TYPE *)          AChoiceSequence;

FROM Menus          IMPORT
    (* TYPE *)          APromptType, AMenuWithPromptsProc,
                        MenuWithPrompts;

FROM MsgFile      IMPORT
    (* CONST *)         TLWhat,
    (* PROC *)          GetMessage, DisplayMessage, ConcatMessage,
                        GetMessageForClass;

FROM Overlays       IMPORT
    (* PROC *)          OverlayPackage;

FROM RunMenu        IMPORT
    (* TYPE *)          AnItem, ASetOfItemAttributes, ADispatchProcedure,
                        AParmArray, AMenuItemList, AnActionString,
                        AParm, AnExceptionEntry, AClassIndex, ADescription,
                        AnExceptionReason,
    (* VAR  *)          ClassList,
    (* PROC *)          LocateItem, GetMenuItem;

FROM Space          IMPORT
    (* PROC *)          ALLOCATE, HeapAvailable;

FROM SpecialCharactors IMPORT
    (* CONST *)         SpecialCharCallOverlay,
                        SpecialCharDispatch,
                        SpecialCharReturnCode,
                        SpecialCharDoMenu,
                        SpecialCharGiveHelp,
                        SpecialCharReturnAction;

FROM SegWords       IMPORT
    (* PROC *)          WordNumber;

FROM SYSTEM         IMPORT
    (* TYPE *)          ADR,
    (* PROC *)          SIZE, TSIZE;

FROM Text           IMPORT
    (* TYPE *)          AText,
    (* PROC *)          CreateText, DiscardText, AppendLine;

FROM TreeObjects    IMPORT
    (* TYPE *)          ATree,      ATreeNode;

FROM Words          IMPORT
    (* PROC *)          ParseBal;

(*<TRACE
FROM Tracer IMPORT PrintString, EndTrace;
TRACE>*)


CONST
    MenuStart             = 0;

    StickyCharacter  = "+";
    SubjectCharacter = "(";  (* Pass following string to history. *)
    SeparatorChar    = ",";
    MaxHelpKeyLength = 8;


    ModuleNumber        = 2800;   (* SAME AS INITMENU! *)

    TLWhatModuleNumber  = 1000;   (* Start here and go up. *)



TYPE
    AClassIndexPtr      = POINTER TO AClassIndex;


    (*<TRACE
VAR
    TraceS : ARRAY [0..255] OF CHAR;
    TraceS2 : ARRAY [0..51] OF CHAR;
    TRACE>*)









PROCEDURE FindClass( VAR Class      : ARRAY OF CHAR;
                     VAR ClassIndex : AClassIndexPtr ) : BOOLEAN;
VAR
    Node            : ATreeNode;
    Found,
    First           : BOOLEAN;
BEGIN
    IF (ClassList = ATree(NIL)) THEN
        Node := ATreeNode(NIL);
    ELSE
        Node := ClassList^.Methods^.GetFirst( ClassList );
    END;

    Found       := FALSE;
    First       := TRUE;

    WHILE (Node <> NIL) AND (NOT Found) DO
        ClassIndex := Node^.Methods^.GetDataObject( Node );
        IF (StringsEqual( Class, ClassIndex^.Class )) THEN
            (* Keep the class list in LRU order to cut down on search time.
               If the class is already at the top, don't bother moving it.
            *)
            IF (NOT First) THEN
                Node^.Methods^.DeList(Node);
                ClassList^.Methods^.AddFirst( ClassList, Node );
            END;
            Found := TRUE;
        ELSE
            First := FALSE;
            Node  := Node^.Methods^.GetNext(Node);
        END;
    END;

    RETURN Found;

END FindClass;






(* 13-May-91 RSC Added CurrentClassIndex param.
*)
PROCEDURE GetPromptText( VAR Text                : AText;
                             CurrentClassIndex   : AClassIndexPtr);
VAR
    N,
    At         : CARDINAL;
    Item       : AnItem;
    ok         : BOOLEAN;
BEGIN
    Text := CreateText();
    N    := 0;
    WHILE (LocateItem( CurrentClassIndex^.Class, (N+1), Item, At )) DO
        INC(N);
        ok := AppendLine( Item.Description, Text );
    END;
END GetPromptText;




PROCEDURE SubstituteParameters( VAR S         : ARRAY OF CHAR;
                                    KeyLetter : CHAR;
                                VAR Parms     : AParmArray);
VAR
   i,j,k : CARDINAL;
   Find  : ARRAY [0..1] OF CHAR;
   C     : CHAR;
BEGIN
    Find[0] := 1C;
    Find[1] := KeyLetter;

    i := 0;
    i := Search( S, Find, (i+1) );
    WHILE (i > 0) AND (i < LengthOf(S)) DO
        C := S[i+1];
        IF (C >= "1") AND (ORD(C)-ORD("0") <= HIGH(Parms)) THEN
            j := i;
            INC(j);
            k := StoC(S,j);
            Remove(S,i,j-i);
            Insert(S,Parms[k],i);
            DEC(i);   (* Rescan *)
        ELSIF (C = KeyLetter) THEN
            Remove(S,i,1);
        END;
        INC(i);

        i := Search( S, Find, (i+1) );
    END;

END SubstituteParameters;







PROCEDURE SelectItemFromMenu(    Prefix     : ARRAY OF CHAR;
                                 ULX        : ascreenx;
                                 ULY        : ascreeny;
                                 LRX        : ascreenx;
                                 LRY        : ascreeny;
                                 BoxType    : ABoxType;
                             VAR ExitCodes  : ASetOfCodes;
                             VAR MenuList   : AMenuItemList;
                             VAR Choice     : CARDINAL;
                             VAR Parms      : AParmArray;
                                 CurrentClassIndex   : AClassIndexPtr;  (* 13-May-91 RSC  *)
                                 MenuWithPromptsProc : AMenuWithPromptsProc
                             ) : ACode;
CONST
    KeyLetter = "&";
VAR
    PromptText  : AText;
    i           : CARDINAL;
    Code        : ACode;
    LocalSet    : ASetOfCodes;
BEGIN
    LocalSet := ExitCodes;

    WITH MenuList DO
        FOR i := 1 TO MenuItems DO
            Code := Codes[i];
            IF (Code <> 0) THEN
                SetCodeBits( LocalSet, Code, Code, TRUE );
            END;
        END;
    END;

    SubstituteParameters( Prefix,              KeyLetter, Parms);
    SubstituteParameters( MenuList.MenuString, KeyLetter, Parms);

    GetPromptText( PromptText, CurrentClassIndex );    (* 15-Apr-91 RSC  *)

    Code := MenuWithPromptsProc(Prefix,
                                MenuList.MenuString,
                                ULX,ULY,LRX,LRY,
                                BoxType, LocalSet,
                                PromptFromText,0,PromptText,
                                FALSE,  (* 11-Dec-89 RSC MODAL? *)
                                Choice);

    DiscardText( PromptText );  (* 15-Apr-91 RSC  *)

        (* If the item was chosen by picking a KeyEquivalent,
           use that. *)

    WITH MenuList DO
        i := 1;
        LOOP
            IF (i > MenuItems) THEN
                EXIT;
            ELSIF (Code = Codes[i]) THEN
                    (* Pretend that the item was chosen from the menu. *)
                Choice := i+1;
                    (* If the client doesn't want this code back,
                       return an innocuous value. *)
                IF NOT ((Code MOD 16) IN ExitCodes[Code DIV 16]) THEN
                    Code := DoIt;
                END;
                EXIT;
            END;
            INC(i);
        END;
    END;

    RETURN (Code);

END SelectItemFromMenu;















    (*  ChooseItem    -- Either processes the overlay as a
                         help call or returns the name in
                         FileName.   Since this routine uses
                         a substantial amount of temporary
                         storage, it is designed to return to
                         a caller who will make the actual
                         overlay invocation.
                         *)


PROCEDURE ChooseItem( VAR Class,
                          Prefix        : ARRAY OF CHAR;
                          ULX           : ascreenx;
                          ULY           : ascreeny;
                          LRX           : ascreenx;
                          LRY           : ascreeny;
                          BoxType       : ABoxType;
                      VAR ExitCodes     : ASetOfCodes;
                      VAR Parms         : AParmArray;
                      VAR Choice        : CARDINAL;
                          ForceChoice   : BOOLEAN;
                      VAR Action        : ARRAY OF CHAR;
                      VAR Dispatch      : ADispatchProcedure;
                          MenuWithPromptsProc : AMenuWithPromptsProc
                     ):ACode;
VAR
    CurrentClassIndex  : AClassIndexPtr;  (* 13-May-91 RSC  *)
    Code        : ACode;
    At,
    Count       : CARDINAL;
    MenuListPtr : POINTER TO AMenuItemList;
    MenuList    : AMenuItemList;
    Item        : AnItem;


    PROCEDURE NoMenuItems();
    VAR
        s : ARRAY [0..255] OF CHAR;  (* Save stack space. RSC 9.14.88 *)
    BEGIN
        GetMessage(ModuleNumber+2,s);   (* "No " *)
        ConcatLS(s,Class);
        ConcatMessage(s,ModuleNumber+3);   (* " menu items." *)
        Error(s);
    END NoMenuItems;


BEGIN

    SetLengthOf(Action,0);

    Code := CancelKey;

    IF (NOT FindClass( Class, CurrentClassIndex ))       OR
       (CurrentClassIndex^.MenuItems = AnExtHandle(NIL)) THEN
        NoMenuItems();
    ELSE
        IF (LockObjectArray( CurrentClassIndex^.MenuItems,
                             MenuListPtr,
                             TSIZE(AMenuItemList) ) = 0) THEN
            FatalError();
        END;
        MenuList    := MenuListPtr^;
        ReleaseUnchangedObject( CurrentClassIndex^.MenuItems );
        MenuListPtr := NIL; (* DEBUG *)


        IF (ForceChoice) THEN
            Code   := DoIt;  (* Pretend that they picked this choice. *)
        ELSIF (MenuList.MenuItems = 1) THEN
            Code   := DoIt;  (* Pretend that they said ok. *)
            Choice := 1;
        ELSE
            Code := SelectItemFromMenu(Prefix,ULX,ULY,LRX,LRY,BoxType,
                                       ExitCodes,
                                       MenuList,
                                       Choice,Parms,
                                       CurrentClassIndex,
                                       MenuWithPromptsProc);
        END;
        ReleaseUnchangedObject( CurrentClassIndex^.MenuItems );
    END;


    IF (Code = DoIt) THEN
        IF (NOT LocateItem( Class, Choice, Item, At )) THEN
            ErrorPhrase(0);
        END;
        WITH Item DO
            Copy(ActionString,Action);
            SubstituteParameters(Action,"&",Parms);
            Dispatch := DispatchProc;
        END;
    END;

    RETURN Code;

END ChooseItem;






PROCEDURE DecodeCode( VAR S : ARRAY OF CHAR ) : ACode;
VAR
    i : CARDINAL;
BEGIN
    i := 1;
    RETURN StoC(S,i);
END DecodeCode;




PROCEDURE DistributeParms ( VAR S : ARRAY OF CHAR;
                            VAR n : CARDINAL;
                            VAR Parms : AParmArray );
VAR
    j : CARDINAL;
BEGIN
          (* Distribute the values returned into the local parms. *)
    j := 1;
    WHILE (j < LengthOf(S)) DO
        IF (n <= HIGH(Parms)) THEN
            ParseBal(S,j,Parms[n]);
            INC(n);
        ELSE
            Error(S);
            j := 9999;
        END;
    END;
END DistributeParms;




PROCEDURE GetParameters       ( VAR S : ARRAY OF CHAR;
                                    ULX : ascreenx;
                                    ULY : ascreeny;
                                    LRX : ascreenx;
                                    LRY : ascreeny;
                                    BoxType : ABoxType;
                                    ExitCodes : ASetOfCodes;
                                VAR Parms     : AParmArray;
                                    MenuWithPromptsProc : AMenuWithPromptsProc
                               ):ACode;
VAR
    ChoiceSequence : ARRAY [0..1] OF CARDINAL;  (* Max supported depth. *)
    Dispatch       : ADispatchProcedure;
    i,Len,Choice,n : CARDINAL;
    Code           : ACode;
    Subject,
    Substitute     : AnActionString;
    Found          : BOOLEAN;
    SearchFor      : ARRAY [0..2] OF CHAR;
BEGIN
    ChoiceSequence[0] := 0;   (* Don't care about the path. *)

    FOR i := 1 TO HIGH(Parms) DO
        SetLengthOf(Parms[i],0);
    END;

    SetString( SearchFor, "?(" );
    i    := Search( S, SearchFor, 1 );
    Code := DoIt;
    n    := 1;

    WHILE (i > 0) AND (Code = DoIt) DO
        Len    := i + 1;
        ParseBal( S, Len, Subject );
        Remove(S,i,Len - i);
        Choice := 1;
        Code   := ExtraFancyMenu(Subject, Subject, ULX, ULY, LRX, LRY,
                                 BoxType,
                                 ExitCodes, Choice,
                                 Substitute,
                                 Dispatch,
                                 0, (* CallDepth *)
                                 ChoiceSequence);
        Found := (LengthOf(Substitute) > 0);
        IF (NOT Found) THEN
            Code := CancelKey;
        ELSIF (Code = DoIt) THEN

              (* Distribute the values returned into the local parms. *)

            DistributeParms( Substitute, n, Parms);
        END;
        i := Search( S, SearchFor, i );
    END;

    RETURN Code;

END GetParameters;







    (* GetObject -- Remove the first part of Action, up to a "(", into
                    Object.  Put remainder (up to balanced ")" back into
                    Action. *)

PROCEDURE ExtractObject( VAR Action : ARRAY OF CHAR;
                         VAR Object: ARRAY OF CHAR );
VAR
    i             : CARDINAL;
    S1            : ARRAY [0..1] OF CHAR;
    Subject       : ARRAY [0..255] OF CHAR;
BEGIN
     (* If the ActionString contains a "(", than
        anything preceding that is the object. *)

    SetString(S1,SubjectCharacter);
    i := Search(Action,S1,1);
    IF (i > 0) THEN
            (* Copy the first part to Object *)
        SubStr(Action,Object,1,i-1);
            (* Extract the subject. *)
        ParseBal(Action,i,Subject);
            (* Put the subject into Action. *)
        Copy(Subject,Action);
    ELSE
        Copy(Action,Object);
        SetLengthOf(Action,0);
    END;
END ExtractObject;


PROCEDURE ExtractSubject( VAR Action : ARRAY OF CHAR;
                          VAR Subject: ARRAY OF CHAR );
VAR
    Object : ARRAY [0..255] OF CHAR;
BEGIN
    ExtractObject(Action,Object);
    Copy(Action,Subject);
    Copy(Object,Action);
END ExtractSubject;




    (* ExtraFancyMenu --
           All sorts of good parameters.
           Make sure you allocate enough vertical space to contain the
           largest possible menu.
           If any code in the ExitCodes is pressed, this will return.
           *)

TYPE
    AMenuContext = RECORD
        ParmString    : AnActionString;
        LParms        : AParmArray;
    END;



PROCEDURE ExtraFancyMenu   (     Class  : ARRAY OF CHAR;
                                 Prefix :ARRAY OF CHAR;
                                 ULX : ascreenx;
                                 ULY : ascreeny;
                                 LRX : ascreenx;
                                 LRY : ascreeny;
                                 BoxType   : ABoxType;
                                 ExitCodes : ASetOfCodes;
                                 InitialChoice : CARDINAL;
                             VAR ReturnString        : ARRAY OF CHAR;
                             VAR Dispatch            : ADispatchProcedure;
                                 CallDepth           : CARDINAL;
                             VAR ChoiceSequence      : ARRAY OF CARDINAL
                            ):ACode;
VAR
    i             : CARDINAL;
    Choice        : CARDINAL;
    ChoiceNumber  : CARDINAL;
    Len           : CARDINAL;
    Code          : ACode;
    Context       : POINTER TO AMenuContext;
    ContextHandle : AnExtHandle;
    ActionString  : AnActionString;
    Type          : CHAR;
    C             : CHAR;
    ok            : BOOLEAN;
    ForceChoice   : BOOLEAN;


BEGIN
        (* We will create our context within FlexStor so that it can be
           released from main memory when not in active use. *)

    IF (CreateExtObjectWithSize(ContextHandle,ExtMedium,SIZE(Context^))) AND
       (LockObject(ContextHandle,Context)=SIZE(Context^))  THEN
    ELSE
        ErrorPhrase(ModuleNumber+4);
        RETURN 0;
    END;

    INC(CallDepth);       (* We are nested this far in the menu sequence. *)
    SetLengthOf(ReturnString,0);


    (*<TRACE
    SetString(TraceS,"Call ExtraFancyMenu, Depth = "); CtoS(CallDepth,TraceS2);  ConcatLS(TraceS,TraceS2);
    PrintString(TraceS);
    SetString(TraceS,"  InitialChoice = "); CtoS(InitialChoice,TraceS2);  ConcatLS(TraceS,TraceS2);
    PrintString(TraceS);
    TRACE>*)


        (* If the Class contains a "(", then
           anything following that is parameters. *)

    ExtractSubject(Prefix,Context^.ParmString);       (* Erase any subject. *)

    ExtractSubject(Class,Context^.ParmString);


        (* Parse the parameter string. *)
    FOR i := 1 TO HIGH(Context^.LParms) DO SetLengthOf(Context^.LParms[i],0); END;
    i := 1;
    DistributeParms(Context^.ParmString,i,Context^.LParms);
        (* Pick an choice.   We do this either by (a) asking the
           user, or (b) simulating the user's choice as a way of
           retracing our steps. *)
    ForceChoice  := FALSE;

    IF (InitialChoice >= 256) THEN
        IF (CallDepth > ChoiceSequence[0]) THEN  (* Error condition. *)
            InitialChoice := 1;
        ELSE
            InitialChoice := ChoiceSequence[ CallDepth ];
            IF (CallDepth < ChoiceSequence[0]) THEN
                ForceChoice := TRUE;
            END;
        END;
    END;

    Code := ChooseItem(Class,Prefix,ULX,ULY,LRX,LRY,
                       BoxType,ExitCodes,Context^.LParms,
                       InitialChoice,
                       ForceChoice,
                       ActionString,Dispatch,MenuWithPrompts);

    IF (NOT ForceChoice) THEN
            (* Record what the choice was. *)
        ChoiceSequence[ CallDepth ] := InitialChoice;
        ChoiceSequence[ 0 ]         := CallDepth;
    END;
    

    IF (Code = DoIt) THEN  (* User choose a menu item. *)

            (* Sometimes the ActionString itself contains substitutable
               parameters that require a submenu.  Do the submenu.  This
               will return a DoIt unless the user chooses a code in the 
               ExitCode set. *)

        Code := GetParameters(ActionString,ULX,ULY,LRX,LRY,
                              BoxType,ExitCodes,  Context^.LParms,
                              MenuWithPrompts);
        SubstituteParameters(ActionString,"%",    Context^.LParms);

            (* Release the context before any nesting stuff. *)

        ReleaseObject(ContextHandle);                 (*<DEBUG Context := NIL; DEBUG>*)

            (* At this point, the user has either pressed a key that is
               in the ExitCodes set, or has chosen a menu item.  If a menu
               item, it will have returned a string in ActionString the 
               indicates what to do. *)

        i := LengthOf(ActionString);

            (* Take action on the "ActionString". *)
        IF ( ( i > 0 ) AND ( Code = DoIt ) ) THEN  (* KKC -- Jun 5, 1989 *)
    
                (* The first letter of [Action] is the type of
                   action to take. *)
            Type := ActionString[1];

        CASE Type OF
            SpecialCharReturnCode :
                Remove(ActionString,1,1);    (* Remove the Type. *)
                Code := DecodeCode( ActionString );
          | SpecialCharDoMenu :
                Remove(ActionString,1,1);    (* Remove the Type. *)
                IF (ForceChoice) THEN
                    Choice := 256;           (* Signal to force next choice. *)
                ELSE
                    Choice := 1;
                END;
                Code := ExtraFancyMenu(ActionString, ActionString,
                                       ULX,ULY,LRX,LRY,
                                       BoxType,
                                       ExitCodes,Choice,
                                       ReturnString,
                                       Dispatch,
                                       CallDepth,
                                       ChoiceSequence);



            ELSE
                    (* Return an action string to be executed
                       by our caller. *)
                Copy(ActionString,ReturnString);
                Code := DoIt;
        END;


        END;
    ELSE
        ReleaseObject(ContextHandle);                 (*<DEBUG Context := NIL; DEBUG>*)
    END;


    DiscardExtObject(ContextHandle);

    (*<TRACE
    SetString(TraceS,"Code = "); CtoS(Code,TraceS2);  ConcatLS(TraceS,TraceS2);
    PrintString(TraceS);
    IF (LengthOf(ReturnString) > 0) THEN
        PrintString(ReturnString);
    END;
    TRACE>*)

    RETURN Code;

END ExtraFancyMenu;

















                                                                        
END RunMenu2.

