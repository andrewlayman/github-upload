IMPLEMENTATION MODULE RunMenu;

    (****************************************************************)
    (*                                                              *)
    (*      RunMenu -- Put up a menu of possible items of           *)
    (*          the class indicated.  If one is picked, run it.     *)
    (*                                                              *)
    (*                                                              *)
    (****************************************************************)

    (*   MODIFICATION HISTORY:

         1/13/86   AJL  -- The processing of help requests has been
                           moved into the main loop.
                        -- Keycodes can now be generated by starting
                           an action with "{".
         5/8/86    AJL  -- Read the file only the first time.
         5/20/86   AJL  -- Add procedure FancyOverlaysMenu.
         5/11/87   AJL  -- Added hook for Chainer module.
                           The NAME section of any line whose class
                           is "+" will be sent to the Chainer module
                           procedure AddModuleName.
         8/13/87   AJL  -- Allow longer Descriptions in Init.
         9/12/87   AJL  -- We now call all overlays using the
                           CallOverlayWithContext procedure, and pass
                           the address of the action string.
         9/19/87   AJL  -- If the action string contains an "(", then
                           the context passed to the CallOverlayWithContext
                           will contain everything past that "(" to
                           a matching ")".
                        -- An @ command, with a non-null subject, will
                           use that subject as the prefix on the menu call.
         9/28/87   AJL  -- Do not add disabled menu items to a menu.
                        -- Store action strings in variable length heap
                           space.
        11/10/87   RSC  -- Increase size of largest action string.
                           Put text file reading into AsciiIO module (new).
        11/19/87   AJL  -- Added new action command, "<", which returns
                           an action string to the caller.
        11/20/87   AJL  -- Added substitutable parameters with the ?(...)
                           and %n syntax.  Each name within
                           ?(...) will cause a menu call.  The list of
                           values returned will be substituted for %1..%9.
                           Multiple ?(...) will assign values to successive
                           parameters.
        11/23/87   AJL  -- Added parameters in the call other menu
                           ("@") command.  These are parsed and substituted
                           for &1 through &9.
        12/02/87   AJL  -- Allow Esc from ?(...) menu.
                        -- Substitute % for %% and & for && when
                           substituting parameters.
         1/20/88   AJL  -- Allow a Class = "-" to suppress any action.
                           A crude comment.  Still requires format of
                           -,,,Comment. 
            ??     AJL  -- Store prompts in FlexStor. 
        2/20/88    AJL  -- When storing prompts into flexstor, only store
                           them when they are not empty lines, and 
                           round up their lengths to an even number. 
        8/16/88    RSC  -- Save space by making record var size.  Other minor
                           Speed/Size improvements.

                           NEW RESTRICTION:

                                OVERLAYS TO BE LOADED AT STARTUP MUST BE FIRST
                                IN THE FILE, AFTER ANY OPTIONAL COMMENTS.
                                NO OTHER LINES MAY BE FIRST!!

        11/3/88    RSC  -- Save stack space by allocating stuff from the heap.
                           Add a LowMemory Warning box.
        11/15/88   RSC  -- Back off from the change of 11/3.  When you run out
                           of heap space, you can't save the schedule.
        12/07/88   AJL  -- In ExtraFancyMenu, took many fields out of the
                           Context, put remainder into FlexStor.
                        -- Use a new procedure, ExtractObject, allowing us to
                           extract the overlay name from ActionString while
                           leaving the largest part of the string still in
                           ActionString.  This greatly reduces stack space.
                        -- Made MaxActionsLength 250.
                        -- Reduced size of AParm from 20 to 19.
                        -- Made NextAction in ExtraFancyMenu be AParm.
        2-Jan-89   RSC  -- Added references to StringsEqual() rather than Compare().
       10-Jan-89   RSC  -- changed Storage to Space.
        2-Feb-89   RSC  -- Changed params to ParseBal.
        3-Feb-89   RSC  -- Split out "InitMenu" from here.
                           Added "SpecialCharactors".
       20-Mar-89   AJL  -- If the prompt is NIL in PromptProc, don't crash.  
       22-May-89   KKC  -- Do not exit if OverlayPackage return FALSE in
                           ExtraFancyMenu
       05-Jun-89   KKC  -- Fixing bugs for Bug Report # 323
                           In ExtraFancyMenu, if GetParameters return an
                           nonzero Code but Sticky is on, do not return.
       19-Jul-89   RSC  -- Do not store the records in a list, but on the
                           phrases file for the class "TLWHAT".
                           Keep an index of items in memory for faster
                           access.  Keep a list of exceptions in FlexStor.
       23-Aug-89   RSC  -- Context areas were being allocated from FlexStor.
                           Changed these allocations from Slow FlexStor to
                           Meduium speed storage.
       11-Dec-89   RSC     Updated call to Menus for new MODAL parameter.
       25-May-90   AJL  -- Changed the format of the lines in the phrases
                           file so that each of the four segments of the menu
                           line are not separated by commas, but are instead
                           surrounded by matched parenthesis.
       11-Apr-91   RSC     Call overlay from within FancyMenu.
       11-Jul-91   AJL  -- Change SelectAndRunMenu to call the new 
                           ExtraFancyMenu, and to take a return action 
                           string.  It, rather than ExtraFancyMenu, 
                           calls overlays and controls sticky menus.
       12-Jul-91   AJL  -- Return a code of zero after acting on a string
                           in ExtraFancyMenu.
    *)

    (*   The actions are controlled by the contents of the file
         TLWHAT.CFG.

         [Class],[Item Description],[Action],[Description]

         If there is only one item of the class, then the action will
         be taken immediately.

         Otherwise, a menu of [Item Description]s will be displayed, and
         the chosen action, if any, will be taken.

         If [Action] begins with "." (period) it is a call to Help.

         If [Action] begins with "@" it selects another class for
            additional menu selection.

         If [Action] begins with "{" it indicates that it is followed
            by a number, whose value is returned.

         If [Action] begins with "=" it indicates that it is followed
            by a number.  We call the dispatcher with this action
            number.

         An [Action] beginning with ">" is the name of an overlay file
            to call.

         An [Action] beginning with "<" will return the following
         characters to the caller.

         If [Action] ends with "+", the menu will be repeated after
         the action is taken.   (This is called being "sticky." )

         If a Name begins with "{", it may be followed by a number.
         The "{", the number and the following character will be removed.
         If the key code read from the keyboard matches this number,
         it will be as though that menu item were selected.

         The following are parameters that can be substituted during
         menu interpretation:

         &1 .. &5   Parameters supplied in a parenthesis in the Class
                    string are substituted into the ItemDescription and
                    Action of each item.

         %1 .. %5   These are parameters that can be obtained by a menu
                    call using the ?(CLASS) syntax.  If the menu identified
                    by the CLASS returns a string, parenthesized items
                    in it are substituted for these parameters.

         ?(Class)   calls a menu and returns a list of parameters.

        *)

FROM Boxes          IMPORT
    (* TYPE *)          ABoxType, ABoxAttribute,
    (* PROC *)          DrawBox;

FROM Chainer        IMPORT
    (* PROC *)          AddModuleName;

FROM Codes          IMPORT
    (* TYPE *)          ACode, ASetOfCodes,
    (* PROC *)          SetCodeBits;

FROM CodeSets       IMPORT
    (* VAR *)           MenuCodeSet;

FROM Dialog         IMPORT
    (* PROC *)          Message, Error, FatalError, Barf, NotYetImplemented;

IMPORT Dispatcher;

FROM FlexStor       IMPORT
    (* TYPE *)          AnExtHandle,      AnExtStoragePreference,
    (* PROC *)          CreateExtObjectWithSize,
                        DiscardExtObject, LockObjectArray,
                        LockObject,       ReleaseObject, 
                        ReleaseUnchangedObject;
 
FROM Helper         IMPORT
    (* TYPE *)          AScreenAction,
    (* PROC *)          GiveHelp;

FROM Kbio           IMPORT
    (* CONST *)         maxcol,
    (* TYPE *)          avidmode, ascreenx, ascreeny,
    (* PROC *)          PushCode;

FROM Keys           IMPORT
    (* CONST *)         DoIt, CancelKey;

FROM Layout         IMPORT
    (* VAR *)           GanttWStart, GanttWEnd;

FROM LStrings       IMPORT
    (* PROC *)          ConcatS, ConcatLS, SetString, StoC, SetLengthOf,
                        SubStr, Fill, StringsEqual, Remove, Copy, Search,
                        LengthOf, Insert, CtoS, Upshift;

FROM Menus          IMPORT
    (* PROC *)          MenuWithPrompts;

FROM MenuHelper     IMPORT
    (* TYPE *)          AMenuContext, AMenuFunction, AChoiceSequence,
    (* PROC *)          DoMenuFunction;

FROM MsgFile        IMPORT
    (* CONST *)         TLWhat,
    (* PROC *)          GetMessage, DisplayMessage, ConcatMessage,
                        GetMessageForClass;

FROM Overlays       IMPORT
    (* PROC *)          OverlayPackage;

FROM ParmLine       IMPORT
    (* PROC *)          GetOption;

FROM Space          IMPORT
    (* PROC *)          ALLOCATE, HeapAvailable;

FROM SpecialCharactors IMPORT
    (* CONST *)         SpecialCharCallOverlay,
                        SpecialCharDispatch,
                        SpecialCharReturnCode,
                        SpecialCharDoMenu,
                        SpecialCharGiveHelp,
                        SpecialCharReturnAction;

FROM SYSTEM         IMPORT
    (* TYPE *)          ADR,
    (* PROC *)          SIZE, TSIZE;

FROM TreeObjects    IMPORT
    (* TYPE *)          ATree,      ATreeNode,
    (* PROC *)          CreateTree, CreateTreeNode;

FROM Words          IMPORT
    (* PROC *)          ParseBal;



CONST
    MenuStart             = 0;

    StickyCharacter  = "+";
    SubjectCharacter = "(";  (* Pass following string to history. *)
    SeparatorChar    = ",";
    MaxHelpKeyLength = 8;


    ModuleNumber        = 2800;   (* SAME AS INITMENU! *)

    TLWhatModuleNumber  = 1000;   (* Start here and go up. *)



TYPE
    AClassIndexPtr      = POINTER TO AClassIndex;


VAR
    CurrentClassIndex   : AClassIndexPtr;
    HighestClassNumber  : CARDINAL;





(* Get Item - Internal procedure to read a message from the message file
              and fill in an Item record.
*)
PROCEDURE GetItem(     ItemNumber : CARDINAL;
                   VAR Item       : AnItem   ) : BOOLEAN;
VAR
    i,
    Position    : CARDINAL;
    s           : ARRAY [0..255] OF CHAR;
    ok          : BOOLEAN;

    (* Position comes in as the index of the byte starting
       the "StringToParse".  Take the next item bracketted by 
       parenthesis, and put as much of it as fits into 
       ReturnedItem.  Update Position to the next character past
       the item returned.
    *)

    PROCEDURE ParseItem( VAR StringToParse  : ARRAY OF CHAR;
                         VAR Position       : CARDINAL;
                         VAR ReturnedItem   : ARRAY OF CHAR );
    VAR
        S : ARRAY [0..255] OF CHAR;
    BEGIN
        ParseBal(StringToParse,Position,S);
        Copy(S,ReturnedItem);
    END ParseItem;


BEGIN
    GetMessageForClass( ItemNumber, TLWhat, s );

    ok := (LengthOf(s) > 0);

    IF (ok) THEN
        WITH Item DO
            Position := 1;
            ParseItem( s, Position, Class        );
            ParseItem( s, Position, ItemName     );
            ParseItem( s, Position, ActionString );
            ParseItem( s, Position, Description );

            Attr         := ASetOfItemAttributes{};
            DispatchProc := Dispatcher.Dispatch;
            Key          := 0;

            IF (ItemName[1] = "{") THEN
                i    := 2;
                Key  := StoC(ItemName,i);
                Remove(ItemName,1,i);
            END;
        END;
    END;

    RETURN ok;

END GetItem;







PROCEDURE FindClass( VAR Class      : ARRAY OF CHAR;
                     VAR ClassIndex : AClassIndexPtr ) : BOOLEAN;
VAR
    Node            : ATreeNode;
    Found,
    First           : BOOLEAN;
BEGIN
    IF (ClassList = ATree(NIL)) THEN
        Node := ATreeNode(NIL);
    ELSE
        Node := ClassList^.Methods^.GetFirst( ClassList );
    END;

    Found       := FALSE;
    First       := TRUE;

    WHILE (Node <> NIL) AND (NOT Found) DO
        ClassIndex := Node^.Methods^.GetDataObject( Node );
        IF (StringsEqual( Class, ClassIndex^.Class )) THEN
            (* Keep the class list in LRU order to cut down on search time.
               If the class is already at the top, don't bother moving it.
            *)
            IF (NOT First) THEN
                Node^.Methods^.DeList(Node);
                ClassList^.Methods^.AddFirst( ClassList, Node );
            END;
            Found := TRUE;
        ELSE
            First := FALSE;
            Node  := Node^.Methods^.GetNext(Node);
        END;
    END;

    RETURN Found;

END FindClass;







(* Locate Item Proc

    Given a class name and an index, try to return the item record that
    corresponds to this.

    Preconditions   - The message file is opened and this module has been
                      initialized.  "LoadMenuTree()" has been called.

    Postconditions  - The item is returned iff TRUE.

    Input Parameters:

        Class       The Class name, as an LString, properly UPSHIFTED or
                    whatever (case is important).
        Index       The Nth item for this menu.  1 is the first.

    Output Parameters:

        IF FALSE,
            No class or indexth entry to the class.

        IF TRUE,
            Item        The item record filled in.
            At          Phrase number containing the item.
*)
PROCEDURE XLocateItem( VAR Class   : ARRAY OF CHAR;
                           Index   : CARDINAL;
                       VAR Item    : AnItem;
                       VAR At      : CARDINAL ) : BOOLEAN;
VAR
    ClassIndexPtr   : AClassIndexPtr;
    Found           : BOOLEAN;


    (* Handle any exceptions.  Return TRUE if the exception was processed.
       FALSE if there was no exception to this entry, or we want to continue
       as if there was no exception.
    *)
    PROCEDURE HandleExceptions(     Exceptions  : AnExtHandle;
                                VAR TargetIndex : CARDINAL;
                                VAR TargetItem  : AnItem;
                                VAR At          : CARDINAL ) : BOOLEAN;
    VAR
        ExceptionEntry  : POINTER TO AnExceptionEntry;
        OldEcxceptions  : AnExtHandle;
        Handled         : BOOLEAN;
    BEGIN
        Handled := FALSE;

        WHILE (Exceptions <> AnExtHandle(NIL)) DO
            IF (LockObject(Exceptions,ExceptionEntry) <> TSIZE(AnExceptionEntry)) THEN
                FatalError();
            END;
            WITH ExceptionEntry^ DO
                IF (Index < TargetIndex)    THEN
                    IF (Reason = Inserted)  THEN    (* A prior insert   *)
                        DEC(TargetIndex);
                    ELSIF (Reason = Deleted) THEN   (* A prior deletion *)
                        INC(TargetIndex);
                    END;
                ELSIF (Index = TargetIndex) THEN
                    IF (Reason = Deleted) THEN   (* A prior deletion *)
                        INC(TargetIndex);
                    ELSE
                        TargetItem := Item;
                        Handled    := TRUE;
                    END;
                END;
                OldEcxceptions := Exceptions;
                Exceptions     := NextException;
            END;
            ReleaseUnchangedObject( OldEcxceptions );
        END;

        RETURN Handled;

    END HandleExceptions;


BEGIN
    At          := 0;
    Found       := FALSE;


    (* First, find the Class in the class list.
    *)
    Found := FindClass( Class, ClassIndexPtr );

    IF (Found) THEN  (* We found the class record. *)

        (* If there are exceptions, deal with them.  Otherwise go
           straight for the message.
        *)
        WITH ClassIndexPtr^ DO
            IF (Exceptions <> AnExtHandle(NIL)) AND
               (HandleExceptions( Exceptions, Index, Item, At )) THEN
            ELSE
                At    := StartingPhrase + (Index - 1);
                Found := (GetItem( At, Item ) AND
                          StringsEqual( Class, Item.Class ));
            END;
        END;
    END;


    RETURN Found;

END XLocateItem;










PROCEDURE GetMenuItem ( VAR Class           : ARRAY OF CHAR;
                            Index           : CARDINAL;
                        VAR Name,
                            Action,
                            Prompt          : ARRAY OF CHAR;
                        VAR KeyEquivalent   : ACode;
                        VAR Attributes      : ASetOfItemAttributes;
                        VAR Dispatch        : ADispatchProcedure
                       ) : BOOLEAN;
VAR
    Item        : AnItem;
    i           : CARDINAL;
    Size        : CARDINAL;
    Description : POINTER TO ADescription;
BEGIN
    IF (LocateItem(Class,Index,Item,i)) THEN
            (* Fill it in. *)
        WITH Item DO
            Copy(ItemName,Name);
            Copy(ActionString,Action);
            Attributes := Attr;
            KeyEquivalent := Key;
            Copy(Description,Prompt);
            Dispatch := DispatchProc;
        END;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END;

END GetMenuItem;











PROCEDURE XExtraFancyMenu  (     Class  : ARRAY OF CHAR;
                                 Prefix :ARRAY OF CHAR;
                                 ULX : ascreenx;
                                 ULY : ascreeny;
                                 LRX : ascreenx;
                                 LRY : ascreeny;
                                 BoxType:    ABoxType;
                                 ExitCodes : ASetOfCodes;
                                 InitialChoice : CARDINAL;
                             VAR ReturnString  : ARRAY OF CHAR;
                             VAR Dispatch       : ADispatchProcedure;
                                 CallDepth      : CARDINAL;
                             VAR ChoiceSequence : ARRAY OF CARDINAL
                            ):ACode;
VAR
    MenuContext : AMenuContext;
    i           : CARDINAL;
BEGIN
    WITH MenuContext DO
        Copy(Class,  CClass);
        Copy(Prefix, CPrefix);
        CULX            := ULX;
        CULY            := ULY;
        CLRX            := LRX;
        CLRY            := LRY;
        CBoxType        := BoxType;
        CExitCodes      := ExitCodes;
        CInitialChoice  := InitialChoice;
        CCallDepth      := CallDepth;
        FOR i := 0 TO HIGH(CChoiceSequence) DO
            CChoiceSequence[i] := ChoiceSequence[i];
        END;

        DoMenuFunction( DoExtraFancyMenu, MenuContext );

            (* Get the return parameters. *)

        InitialChoice   := CInitialChoice;

        FOR i := 0 TO HIGH(ChoiceSequence) DO
            ChoiceSequence[i] := CChoiceSequence[i];
        END;

        Copy(CReturnString, ReturnString );
        Dispatch := CDispatch;

        RETURN ReturnCode;
    END;
END XExtraFancyMenu;





PROCEDURE DecodeCode( VAR S : ARRAY OF CHAR ) : ACode;
VAR
    i : CARDINAL;
BEGIN
    i := 1;
    RETURN StoC(S,i);
END DecodeCode;





PROCEDURE SelectAndRunMenu   ( VAR Class,Prefix:ARRAY OF CHAR):ACode;
VAR
    ChoiceSequence:AChoiceSequence;
    Choice, i    : CARDINAL;
    CallDepth    : CARDINAL;
    ReturnString : ARRAY [0..255] OF CHAR;
    Dispatch     : ADispatchProcedure;
    Code         : ACode;
    S1           : ARRAY [0..11] OF CHAR;
    Type         : CHAR;
    Sticky       : BOOLEAN;
    StickOnEscape: BOOLEAN;
    Found        : BOOLEAN;
BEGIN
        (* If the run line contains "MENU IS LOTUS" then we will 
           only go back one level per escape press. *)
    GetMessage(ModuleNumber+5,S1);    (* "MENU" *)
    GetOption(S1,Found,ReturnString);
    IF (Found) THEN
        Upshift(ReturnString);
        GetMessage(ModuleNumber+6,S1);    (* "LOTUS" *)
        StickOnEscape := StringsEqual(ReturnString,S1);
    ELSE
        StickOnEscape := FALSE;
    END;


    SetLengthOf(S1,0);
    Message(S1);

    Code := 0;
    Choice := 1;

    ChoiceSequence[0] := 0;    (* Starting at top level. *)

    Sticky := FALSE;

    
    REPEAT
            (* If we are being sticky, then return again to the position
               of the last choice. *)

        IF (Sticky) THEN
            Choice := 256;     (* Signal to use the ChoiceSequence to return. *)
        END;

        CallDepth         := 0;

        Code := ExtraFancyMenu(Class,Prefix,
                               0,MenuStart,maxcol,GanttWStart-1,
                               ABoxType{NoBox},
                               MenuCodeSet,Choice,
                               ReturnString,  Dispatch,
                               CallDepth,
                               ChoiceSequence);
    
            (* After executing this menu choice, do we exit, or do
               we return to the menu and re-present the choices? *)

        i := LengthOf(ReturnString);
        IF (i > 0) AND (ReturnString[i] = StickyCharacter) THEN
            Sticky := TRUE;
            DEC(i);
            SetLengthOf(ReturnString,i); (* Remove the final character. *)
        ELSE
            Sticky   := FALSE;
        END;

            (* What does the menu choice indicate to do? *)

    
        IF (Code=DoIt) AND (i > 0) THEN (* Return value is in the string. *)
                (* The first letter of [Action] is the type of
                   action to take. *)
            Type := ReturnString[1];
            Remove(ReturnString,1,1);    (* Remove the Type. *)
    
            Code := 0;

            CASE Type OF
                SpecialCharReturnCode :
                       Remove(ReturnString,1,1);    (* Remove the Type. *)
                       Code := DecodeCode( ReturnString );
              | SpecialCharCallOverlay :
                       IF (NOT OverlayPackage( ReturnString )) THEN
                           Code := CancelKey;
                       END;
              | SpecialCharDispatch :
                       Dispatch( DecodeCode( ReturnString ) );
              | SpecialCharGiveHelp :
                       GiveHelp(ReturnString,GanttWStart,GanttWEnd,
                                RestoreTheScreen);
                ELSE
                      Error(ReturnString);
            END;
    
        ELSE
                (* Menu choices that do not return an action string
                   are not permitted to be sticky. *)
            Sticky := FALSE;

                (* Depending on the mode of the program, controlled
                   by the StickOnEscape flag, the Escape key may exit
                   entirely, or may just back up one level. *)

            IF (Code = CancelKey) AND (StickOnEscape) THEN
                IF (ChoiceSequence[0] > 1) THEN
                    DEC(ChoiceSequence[0]);  (* Back one level. *)
                    Sticky := TRUE;          (* Go to that level. *)
                END;
            END;
        END;

    UNTIL NOT Sticky;
    
             
    RETURN Code;
END SelectAndRunMenu;





PROCEDURE ExecuteMenu( VAR Class,Prefix:ARRAY OF CHAR);
VAR
    Code        : ACode;
BEGIN
    Code := SelectAndRunMenu( Class, Prefix );
END ExecuteMenu;





    (*-----------------------------------------------------------------

        LoadMenuTree

        Preconditions:
            The message file is open.
            Chainer has initialized.

        Postconditions:
            Chainer has all the modules needed to start Time Line.

    -----------------------------------------------------------------*)

PROCEDURE LoadMenuTree();
CONST
    AtStart = "+";
VAR
    ItemNumber  : CARDINAL;
    Item        : AnItem;
BEGIN

    ItemNumber := TLWhatModuleNumber;

    WHILE (GetItem( ItemNumber, Item )) AND
          (Item.Class[1] = AtStart)     DO
        AddModuleName(Item.ItemName);
        INC( ItemNumber );
    END;

END LoadMenuTree;







    (*-----------------------------------------------------------------

        AddToMenuTree

        Preconditions:
            The message file must be open.
            There must be a fair amount of free memory.
            FlexStor must be running.

        Postconditions:
            The menu system can be used.  Before this, there ARE NO
            MENU ITEMS.

    -----------------------------------------------------------------*)

PROCEDURE AddToMenuTree();
CONST
    AtStart = "+";
VAR
    MenuItemListCount,
    ItemNumber      : CARDINAL;
    Node            : ATreeNode;
    Item            : AnItem;
    ClassIndex      : AClassIndex;
    IndexPtr        : AClassIndexPtr;
    MenuItemList    : AMenuItemList;
    Separator       : ARRAY [0..1] OF CHAR;


    PROCEDURE CloseOffEntry( Index : AClassIndexPtr );
    VAR
        i           : CARDINAL;
        MenuListPtr : POINTER TO AMenuItemList;
    BEGIN
        IF (MenuItemList.MenuItems <> 0) AND (Index <> NIL) THEN
            IF (CreateExtObjectWithSize( Index^.MenuItems, ExtMedium, TSIZE(AMenuItemList) )) THEN
                IF (LockObject( Index^.MenuItems, MenuListPtr ) = 0) THEN
                    FatalError();
                END;
                MenuListPtr^ := MenuItemList;
                ReleaseObject( Index^.MenuItems );
            ELSE
                Index^.MenuItems := AnExtHandle(NIL);
            END;
        END;
    END CloseOffEntry;


BEGIN

    (* If we have done this before, or there is not enough room
       to do it now, well, vamoose.
    *)
    IF (ClassList <> ATree(NIL))    OR
       (NOT HeapAvailable())        OR
       (NOT CreateTree(ClassList))  THEN
        RETURN;
    END;

    SetString( ClassIndex.Class, AtStart ); (* Skip the "+" entries. *)
    ItemNumber              := TLWhatModuleNumber;
    IndexPtr                := NIL;
    MenuItemList.MenuItems  := 0;
    SetLengthOf( Separator, 1 );
    Separator[1]            := SeparatorChar;

    WHILE (GetItem( ItemNumber, Item )) DO
        WITH ClassIndex DO
            IF (NOT StringsEqual( Class, Item.Class )) THEN

                (* First, close off any prior entry.
                *)
                CloseOffEntry( IndexPtr );


                (* Now, start a new entry.
                *)
                MenuItemList.MenuItems  := 0;
                Copy( Item.Class, Class );
                Exceptions      := AnExtHandle(NIL);
                StartingPhrase  := ItemNumber;
                    (* Number the new class. *)
                INC(HighestClassNumber);
                Item.ClassNumber := HighestClassNumber;
                    (* Add it as a new tree node. *)
                IF (CreateTreeNode( Node )) THEN
                    NEW(IndexPtr);
                    IndexPtr^ := ClassIndex;
                    ClassList^.Methods^.AddLast( ClassList, Node );
                    Node^.Methods^.SetDataObject( Node, IndexPtr );
                END;
            END;
        END;

        WITH MenuItemList DO
            INC(MenuItems);
            Codes[ MenuItems ] := Item.Key;
            IF (MenuItems = 1) THEN
                Copy( Item.ItemName, MenuString );
            ELSE
                ConcatLS( MenuString, Separator );
                ConcatLS( MenuString, Item.ItemName );
            END;
        END;
        INC(ItemNumber);
    END;


    (* Close off the last entry.
    *)
    CloseOffEntry( IndexPtr );

END AddToMenuTree;







PROCEDURE Init();
BEGIN
    CurrentClassIndex   := NIL;
    LocateItem          := XLocateItem;
    ClassList           := ATree(NIL);
END Init;

                                                                        
BEGIN
    ExtraFancyMenu     := XExtraFancyMenu;          
    HighestClassNumber := 0;
    Init();
END RunMenu.


