    (*V1=PRODUCTION Fast enough to ship. *)
    (*V2=DEBUG Extra checking code. *)
    (*V3=TRACE Extra code to allow debugging and tracing. *)
    (*V4=PARANOID Requires TRACE. Adds checksumming. *)
    (*V5=STATISTICS Tracks some statistics on locks. *)
    (*V6=OS2 OS/2 code changes. *)
    (*V7=DOS Regular DOS TL code. *)

    (* WARNING -- Check comments labled "WARNING" for secret tricks,
                  assumptions, short cuts and other risky stuff. *)



IMPLEMENTATION MODULE FlexStor;

  (* MODIFICATION HISTORY   (Original Author AJL)

        5/6/87  RSC  Made Handle a VAR on the Discard call.
                     Activated "HandleIsValid".
        5/7/87  AJL  Added Get and Set procs for Tag and Storage
                     preference.  Added CopyExtObject proc.
                     Added AnExtTagSet.
        5/7/87  RSC  Delete change size routine.  Add MakeHeapCopy and
                     SaveHeapCopy.  Ajust some other minor things.
       5/12/87  RSC  debugging fixes.  caller beware that you may get back
                     a size of 0 from calls! 
        5/13/87  RSC  Added new parameters to get and put calls.  Added
                      "ArraySize" and "NumberOfElements" functions.
       5/21/87   AJL  Rewriting for new record structures, pages, etc.
       7/7/87    AJL  Code is here to create and discard pages via the
                      PageSupply, but not to retrieve them or write them.
       7/30/87   AJL  Removed Tags.
       8/28/87   AJL  Added a basic initialization call to module init.
       9/3/87    AJL  Fixed SetManyExtObjects.
       9/15/87   AJL -Added the Version switch "RELEASE".  If not chosen,
                      then the ReleasePage procedure will not be called,
                      meaning that the PageSupply module must itself
                      check the lock count in the page header before
                      moving a page.
                 AJL -SetExtSize will return FALSE if a size that is
                      too large is requested.
                 AJL -Fix the calculation of the page overhead.
                 AJL -Removed CheckSumThePageTable.
                     -Moved the debugging diagnostics to other
                      modules, FlexTrace and FlexDbug.
                     -Fuss about odd-sized objects.
                 AJL -Changed calls to WritePage to just setting the
                      Dirty flag in the header.
                 AJL -Made it the responsibility of the PageSupply
                      to set PageTable[ ].Location to NIL when the
                      page is not in memory.
                     -Removed WritePage and ReleasePage.
                     -Added GetExtStatus.
      07-Jan-88 LAA  -Added ReleaseUnchangedHandle to implement the 
                      UnlockUnchangedDataObject method of TreeObjects.
      12-Jan-88 AJL  -Moved the setting of the page's dirty bit from the
                      Lock to the Unlock call.
                     -Fixed a bug in which the ReleaseUnchangedHandle was
                      clearing the dirty bit.  No one except the PageSupply
                      should do this.
      19-Jan-88 AJL  -We are using a count in the PageTable records, FreeBytes,
                      that records the amount of free space in each record (though
                      it may be discontinuous).  This is to speed up the 
                      creation of new objects so that we can avoid reading
                      pages into memory that do not have enough room for the
                      object.
      25-Jan-88      -Changed NextClass so that we are more reluctant to 
                      allocate Fast memory. 
      28-Jan-88      -After Discarding a handle, check to see if we can
                      discard the cell block that contains it.
      29-Jan-88      -Improved the internals of the DiscardEmptyCelBlocks call.
      17-Feb-88      -Implemented GetExtStoragePreference.
                     -Turned many calls of NotYEtImplemented into ReportError;
      20-Feb-88      -Odd lengthed itemes now do not call ReportError, but
                      merely Trace, and only if DEGUG is on.
       8-Mar-88  AJL -Changed to use a status record returned from PageClassStatus. 
       9-Mar-88  AJL -Corrected an error in ReportErrorPhrase. 
       5-Oct-88  AJL -Moved the management of records within pages to FlexPage.
                     -Moved LockHandle code internal to LockObject for speed.
                      Ditto for ReleaseObject and ReleaseUnchangedObject.
                     -Word-aligned some variables for speed.
      12-Oct-88  RSC -Fixed uninitialized variable "OK".  Made it TRUE.
      27-Oct-88  AJL -Removed the restriction that made all records at least
                      30 bytes long.  This is necessary since CreateExtObjWithSize
                      no longer corrects the size of an object after creating 
                      it.
      10-Jan-89 RSC  -Changed Storage to Space.
      22-Feb-89 AJL  -APageNo is now 16 bits, not 8 bits.
                     -PageTable is now a pointer. 
      05-Aug-89 WKH  -First edits for OS/2.
      11-Aug-89 RSC  -Full OS/2 implementation.
      21-Aug-89 RSC  -Alter definition of GetExtStatus to return queazy if
                      we run low on FlexStor memory from Medium or Slow
                      storage (DOS only).
      12-Sep-89 AJL  -Correct comment:  ; Now AX:DX is the normalized address

      25-Sep-89 LAA  -Return a status of BAD when interlocked.  This will
                      allow Rugs to still get space for a rug even when we're
                      low on space, but not when we're interlocked.

      13-Nov-89 RSC  -Change the limit of the array of the cell block table.
                      The table is allocated as ARRAY CHAR OF ...., but the
                      limit was set as 255C, not 377C.

      14-Nov-89 RSC - Make Create, Lock, UnLock, and Dispose be stealable.
                      In the past, this could have helped us in debugging
                      nasty problems, and so I assume that it will help
                      us in the future.  Heh, heh, heh....

      17-Nov-89 RSC - Yes.  Well.  Ahem.  My fix of 13-Nov was not as well
                      tested as I thought.  It seems that if you delete all
                      cells in a cell block, you hang on a WHILE () loop.
                      See my date stamp around line 1200.
      12-Jun-90 AJL - Add the ability to EnlargePageTable if we want to 
                      dynamically add more pages during AddPage.
       3-Jun-90 AJL - Modify CopyExtHandle so it won't have an aliasing problem
                      when the same variable is passed in as both OriginalHandle
                      and NewHandle.

      29-Aug-90 CL  - Initialize Size to 0 in MakeHeapCopy.             
      14-Dec-90 AJL - Added tracking of locked handles when both the STATISTICS
                      and DEBUG versions are on.
       2-Jan-91 AJL - Moved      StorageError();
        RETURN FALSE;
    END;
    (*DEBUG>*)


    WITH PageTable^[PageNum] DO

        IF (Location = NIL) AND
           (NOT RetrievePage(StorageClass,PageNum)) THEN
            StorageError();
            RETURN FALSE;
        END;
        Page   := Location;
        IF (Gen <> Page^.Generation[RecNo]) THEN
            RETURN FALSE;
        END;
    END;


    RETURN TRUE;

END CheckAndDecodeHandle;
(*DOS>*)

    (*$R=*)  (*$S=*)  (*$T=*)





    (*<TRACE


(*<DOS*)
PROCEDURE CheckSumTheCellTable();
BEGIN
    (*<PARANOID
    CellTableCheck := CheckSum(CellBlockTable[0C],SIZE(CellBlockTable[0C]));
    PARANOID>*)
END CheckSumTheCellTable;
(*DOS>*)








(*<DOS*)
PROCEDURE TestCheckSums(VAR Page:APage);
BEGIN
    (*<PARANOID
   IF (CheckSum(CellBlockTable[0C],SIZE(CellBlockTable[0C])) <> CellTableCheck) THEN
       StorageError();
   END;
   TestPageCheckSum(Page);
    PARANOID>*)
END TestCheckSums;

(*DOS>*)
    TRACE>*)






PROCEDURE StorageError();
VAR
    S  : ARRAY [0..99] OF CHAR;
    S2 : ARRAY [0..5]  OF CHAR;
BEGIN
    GetMessage( ModuleNumber + 0, S ); (* "Storage Manager (ExtStora) error$Total cells =" *)
(*<DOS*)
    CtoS(Quantity,S2);
    ConcatLS(S,S2);
    INC(Interlock);
(*DOS>*)
    Error(S);

    FatalError();
    (* DEC(Interlock); *)

END StorageError;









    (* InitExtStorage -- Initialize the ExtStorage module.

       Preconditions  -- The Storage module must     StorageError();
        RETURN FALSE;
    END;
    (*DEBUG>*)


    WITH PageTable^[PageNum] DO

        IF (Location = NIL) AND
           (NOT RetrievePage(StorageClass,PageNum)) THEN
            StorageError();
            RETURN FALSE;
        END;
        Page   := Location;
        IF (Gen <> Page^.Generation[RecNo]) THEN
            RETURN FALSE;
        END;
    END;


    RETURN TRUE;

END CheckAndDecodeHandle;
(*DOS>*)

    (*$R=*)  (*$S=*)  (*$T=*)





    (*<TRACE


(*<DOS*)
PROCEDURE CheckSumTheCellTable();
BEGIN
    (*<PARANOID
    CellTableCheck := CheckSum(CellBlockTable[0C],SIZE(CellBlockTable[0C]));
    PARANOID>*)
END CheckSumTheCellTable;
(*DOS>*)








(*<DOS*)
PROCEDURE TestCheckSums(VAR Page:APage);
BEGIN
    (*<PARANOID
   IF (CheckSum(CellBlockTable[0C],SIZE(CellBlockTable[0C])) <> CellTableCheck) THEN
       StorageError();
   END;
   TestPageCheckSum(Page);
    PARANOID>*)
END TestCheckSums;

(*DOS>*)
    TRACE>*)






PROCEDURE StorageError();
VAR
    S  : ARRAY [0..99] OF CHAR;
    S2 : ARRAY [0..5]  OF CHAR;
BEGIN
    GetMessage( ModuleNumber + 0, S ); (* "Storage Manager (ExtStora) error$Total cells =" *)
(*<DOS*)
    CtoS(Quantity,S2);
    ConcatLS(S,S2);
    INC(Interlock);
(*DOS>*)
    Error(S);

    FatalError();
    (* DEC(Interlock); *)

END StorageError;









    (* InitExtStorage -- Initialize the ExtStorage module.

       Preconditions  -- The Storage module must be installed and
                         active.
                         MaxDataSizeWanted must be > 0.

       Postconditions -- The ExtStorage module will be ready to store
                         and retrieve objects, or else FALSE will be
                         returned.

                         When TRUE is returned, the system will be
                         ready to store objects up to MaxDataSizeAvailable
                         bytes long.
    *)

PROCEDURE InitExtStorage(      MaxDataSizeWanted    : CARDINAL
                        ) : BOOLEAN;
VAR
(*<DOS*)
    Class : APageClass;
    Size  : CARDINAL;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    Trace("InitExtStorage");
        TRACE>*)

    MinPageSize := 0FFFFH;
    MaxPageSize := 0;

    FOR Class := PageFast TO PageSlow DO
        Size := StartupPageClass(Class);
        ClassPageSize[Class]  := Size;
        IF (Size > 0) THEN
            IF (Size < MinPageSize) THEN
                MinPageSize := Size;
            END;
            IF (Size > MaxPageSize) THEN
                MaxPageSize := Size;
            END;
        END;
    END;

    IF (MaxPageSize < MinPageSize) THEN   (* No storage classes active *)
        StorageError();
    END;

    MaxDataBytesPerPage := MinPageSize - PageOverhead;

    RETURN (MaxDataSizeWanted <= MaxDataBytesPerPage);
(*DOS>*)
(*<OS2
    RETURN TRUE;
OS2>*)
END InitExtStorage;








    (* MaximumRecordSize  --

       Preconditions  -- The Storage module must be installed and
                         active.

       Postconditions -- We return the size, in bytes, of the largest
                         record that we can handle.
    *)

PROCEDURE MaximumRecordSize(): CARDINAL;
BEGIN
(*<DOS*)
    RETURN MaxDataBytesPerPage;
(*DOS>*)
(*<OS2
    RETURN MaxShort;
OS2>*)
END MaximumRecordSize;











(*<DOS*)
PROCEDURE NextClass( VAR Class : APageClass; Tried : AClassSet );
BEGIN
    CASE Class OF
          PageFast     : Class := PageMedium;
        | PageMedium   : Class := PageSlow;
        | PageSlow     : Class := PageMedium;
    END;
    IF (Class IN Tried) THEN
        Class := PageFast;
        WHILE (Class IN Tried) AND (Class < PageSlow) DO INC(Class); END;
    END;
END NextClass;
(*DOS>*)




(*<DOS*)
PROCEDURE FindAvailablePageClass(     Storage : AnExtStoragePreference;
                                      Size    : CARDINAL )
                                  : APageClass;
VAR
    Class : APageClass;
    Tried : AClassSet;
BEGIN

        (* Find a page class that is active.  This routine will
           not always return the requested page class, but will
           search for alternate classes if the original is unavailable. *)

    Class := APageClass(Storage);
    Tried := AClassSet{};

    WHILE (Tried <> AClassSet{PageFast,PageMedium,PageSlow}) DO
        INCL(Tried,Class);
        IF (ClassPageSize[Class] >= (Size + PageOverhead)) THEN
            RETURN Class;
        END;
        NextClass(Class,Tried);
    END;


    StorageError();
END FindAvailablePageClass;
(*DOS>*)




(*<DOS*)
PROCEDURE MakeNewPage( VAR PageNo   : APageNo;
                           Storage  : AnExtStoragePreference
                     ) : BOOLEAN;
VAR
    Page : APagePointer;
    PageSize : CARDINAL;
    PageHandle : APageHandle;
    Class      : APageClass;
    Tried : AClassSet;
BEGIN
    Tried := AClassSet{};

    Class := FindAvailablePageClass(Storage,1);


        (* This routine assumes that MaxPages > 0 *)

    WHILE (Tried <> AClassSet{PageFast,PageMedium,PageSlow}) DO
        INCL(Tried,Class);

            (* Try to create a page in this class. *)
        PageNo := 1;
        LOOP
            IF (PageNo > MaxPages) THEN           (* Page table is too small? *)
                IF (EnlargePageTable(64)) THEN    (* Changes PageTable and MaxPages! *)
                ELSE
                    ReportErrorPhrase(1);
                    RETURN FALSE;                 (* No ability to enlarge the page table. *)
                END;
            END;
                (*<DEBUG*)
            IF (ORD(PageTable^[PageNo].Valid) > 1) THEN   (* Undefined? *)
                StorageError();
            END;
                (*DEBUG>*)
            IF (NOT PageTable^[PageNo].Valid) THEN
                IF (CreatePage( Class, PageNo, PageSize ) ) THEN
                    WITH PageTable^[PageNo] DO
                        StorageClass := Class;
                        Valid        := TRUE;
                        Page         := Location;
                    END;
                    InitializePage(Page^,PageSize,PageNo);
                    PageTable^[PageNo].FreeBytes := Page^.Header.DataBytesThisPage;
                    MarkPageDirty(Page^);
                    LastPageAdded[ Class ] := PageNo;
                    RETURN TRUE;
                ELSE
                    LotsOfRoom[ Class ] := FALSE;
                    EXIT;
                END;
            END;
            INC(PageNo);
        END;

        NextClass(Class,Tried);

    END; (* While not tried all page classes. *)

    ReportErrorPhrase(1);

    RETURN FALSE;
END MakeNewPage;
(*DOS>*)





















(*<DOS*)
PROCEDURE FindExistingRoomFor(     Size     : CARDINAL;
                                   Class    : APageClass;
                               VAR PageNo   : CARDINAL
                              ) : BOOLEAN;
VAR
    Page : APagePointer;
    Tried : AClassSet;
BEGIN
        (*<TRACE
    IF (Size > MaxRecordSize) THEN
        FatalError();
    END;
        TRACE>*)

        (* Can we find an existing page of this class with enough
           memory.  There are several reasons that might prevent us:
           1.  There are no pages of this class.
           2.  There are none with enough room.
           3.  It is not possible to add more pages of this class.
        *)

          (* Search this class for an availab     : AnExtStoragePreference;
    PageNo            : APageNo;
    RecNo, NewRecNo   : ARecordNo;
    CannotChangeSize  : BOOLEAN;
    HeapAddress       : ADDRESS;
(*DOS>*)
(*<OS2
    TempPtr           : ADDRESS;
    CopySize          : CARDINAL;
OS2>*)

BEGIN
(*<DOS*)
        (*<TRACE
    TraceHandleAndSize("SetExtSize",Handle,NewSize);
    TraceOff();
        TRACE>*)

        (*<TRACE
    IF ODD(NewSize) THEN
        TraceHandleAndSize("Odd-sized ",Handle,NewSize);
    END;
        TRACE>*)

        (* Get the page and record number. *)
    IF (NOT CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        RETURN FALSE;
    END;

    IF HandleIsLocked(Handle) THEN
        StorageError();
    END;

        (* Determine if we can move other records around, or
           whether we must keep other records in this page in
           place.  The test to allow the last record to always
           change size is important to prevent this routine
           from going into infinite recursion. *)

    CannotChangeSize := (Page^.Header.LockCount > 0)
                        AND
                        (RecNo+1 < Page^.Header.LastEntry);

    CurrentSize := SizeOfRecord(Page^,RecNo);

    ShiftLength := Page^.StartAt[Page^.Header.LastEntry]
                   - Page^.StartAt[RecNo+1];

        (* Move the other records in the array. *)

    IF (NewSize = CurrentSize) THEN
       (* Nothing *)

    ELSIF (NewSize > CurrentSize)     (* Bigger *)
       OR (CannotChangeSiz     StorageError();
        RETURN FALSE;
    END;
    (*DEBUG>*)


    WITH PageTable^[PageNum] DO

        IF (Location = NIL) AND
           (NOT RetrievePage(StorageClass,PageNum)) THEN
            StorageError();
            RETURN FALSE;
        END;
        Page   := Location;
        IF (Gen <> Page^.Generation[RecNo]) THEN
            RETURN FALSE;
        END;
    END;


    RETURN TRUE;

END CheckAndDecodeHandle;
(*DOS>*)

    (*$R=*)  (*$S=*)  (*$T=*)





    (*<TRACE


(*<DOS*)
PROCEDURE CheckSumTheCellTable();
BEGIN
    (*<PARANOID
    CellTableCheck := CheckSum(CellBlockTable[0C],SIZE(CellBlockTable[0C]));
    PARANOID>*)
END CheckSumTheCellTable;
(*DOS>*)








(*<DOS*)
PROCEDURE TestCheckSums(VAR Page:APage);
BEGIN
    (*<PARANOID
   IF (CheckSum(CellBlockTable[0C],SIZE(CellBlockTable[0C])) <> CellTableCheck) THEN
       StorageError();
   END;
   TestPageCheckSum(Page);
    PARANOID>*)
END TestCheckSums;

(*DOS>*)
    TRACE>*)






PROCEDURE StorageError();
VAR
    S  : ARRAY [0..99] OF CHAR;
    S2 : ARRAY [0..5]  OF CHAR;
BEGIN
    GetMessage( ModuleNumber + 0, S ); (* "Storage Manager (ExtStora) error$Total cells =" *)
(*<DOS*)
    CtoS(Quantity,S2);
    ConcatLS(S,S2);
    INC(Interlock);
(*DOS>*)
    Error(S);

    FatalError();
    (* DEC(Interlock); *)

END StorageError;









    (* InitExtStorage -- Initialize the ExtStorage module.

       Preconditions  -- The Storage module must be installed and
                         active.
                         MaxDataSizeWanted must be > 0.

       Postconditions -- The ExtStorage module will be ready to store
                         and retrieve objects, or else FALSE will be
                         returned.

                         When TRUE is returned, the system will be
                         ready to store objects up to MaxDataSizeAvailable
                         bytes long.
    *)

PROCEDURE InitExtStorage(      MaxDataSizeWanted    : CARDINAL
                        ) : BOOLEAN;
VAR
(*<DOS*)
    Class : APageClass;
    Size  : CARDINAL;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    Trace("InitExtStorage");
        TRACE>*)

    MinPageSize := 0FFFFH;
    MaxPageSize := 0;

    FOR Class := PageFast TO PageSlow DO
        Size := StartupPageClass(Class);
        ClassPageSize[Class]  := Size;
        IF (Size > 0) THEN
            IF (Size < MinPageSize) THEN
                MinPageSize := Size;
            END;
            IF (Size > MaxPageSize) THEN
                MaxPageSize := Size;
            END;
        END;
    END;

    IF (MaxPageSize < MinPageSize) THEN   (* No storage classes active *)
        StorageError();
    END;

    MaxDataBytesPerPage := MinPageSize - PageOverhead;

    RETURN (MaxDataSizeWanted <= MaxDataBytesPerPage);
(*DOS>*)
(*<OS2
    RETURN TRUE;
OS2>*)
END InitExtStorage;








    (* MaximumRecordSize  --

       Preconditions  -- The Storage module must be installed and
                         active.

       Postconditions -- We return the size, in bytes, of the largest
                         record that we can handle.
    *)

PROCEDURE MaximumRecordSize(): CARDINAL;
BEGIN
(*<DOS*)
    RETURN MaxDataBytesPerPage;
(*DOS>*)
(*<OS2
    RETURN MaxShort;
OS2>*)
END MaximumRecordSize;











(*<DOS*)
PROCEDURE NextClass( VAR Class : APageClass; Tried : AClassSet );
BEGIN
    CASE Class OF
          PageFast     : Class := PageMedium;
        | PageMedium   : Class := PageSlow;
        | PageSlow     : Class := PageMedium;
    END;
    IF (Class IN Tried) THEN
        Class := PageFast;
        WHILE (Class IN Tried) AND (Class < PageSlow) DO INC(Class); END;
    END;
END NextClass;
(*DOS>*)




(*<DOS*)
PROCEDURE FindAvailablePageClass(     Storage : AnExtStoragePreference;
                                      Size    : CARDINAL )
                                  : APageClass;
VAR
    Class : APageClass;
    Tried : AClassSet;
BEGIN

        (* Find a page class that is active.  This routine will
           not always return the requested page class, but will
           search for alternate classes if the original is unavailable. *)

    Class := APageClass(Storage);
    Tried := AClassSet{};

    WHILE (Tried <> AClassSet{PageFast,PageMedium,PageSlow}) DO
        INCL(Tried,Class);
        IF (ClassPageSize[Class] >= (Size + PageOverhead)) THEN
            RETURN Class;
        END;
        NextClass(Class,Tried);
    END;


    StorageError();
END FindAvailablePageClass;
(*DOS>*)




(*<DOS*)
PROCEDURE MakeNewPage( VAR PageNo   : APageNo;
                           Storage  : AnExtStoragePreference
                     ) : BOOLEAN;
VAR
    Page : APagePointer;
    PageSize : CARDINAL;
    PageHandle : APageHandle;
    Class      : APageClass;
    Tried : AClassSet;
BEGIN
    Tried := AClassSet{};

    Class := FindAvailablePageClass(Storage,1);


        (* This routine assumes that MaxPages > 0 *)

    WHILE (Tried <> AClassSet{PageFast,PageMedium,PageSlow}) DO
        INCL(Tried,Class);

            (* Try to create a page in this class. *)
        PageNo := 1;
        LOOP
            IF (PageNo > MaxPages) THEN           (* Page table is too small? *)
                IF (EnlargePageTable(64)) THEN    (* Changes PageTable and MaxPages! *)
                ELSE
                    ReportErrorPhrase(1);
                    RETURN FALSE;                 (* No ability to enlarge the page table. *)
                END;
            END;
                (*<DEBUG*)
            IF (ORD(PageTable^[PageNo].Valid) > 1) THEN   (* Undefined? *)
                StorageError();
            END;
                (*DEBUG>*)
            IF (NOT PageTable^[PageNo].Valid) THEN
                IF (CreatePage( Class, PageNo, PageSize ) ) THEN
                    WITH PageTable^[PageNo] DO
                        StorageClass := Class;
                        Valid        := TRUE;
                        Page         := Location;
                    END;
                    InitializePage(Page^,PageSize,PageNo);
                    PageTable^[PageNo].FreeBytes := Page^.Header.DataBytesThisPage;
                    MarkPageDirty(Page^);
                    LastPageAdded[ Class ] := PageNo;
                    RETURN TRUE;
                ELSE
                    LotsOfRoom[ Class ] := FALSE;
                    EXIT;
                END;
            END;
            INC(PageNo);
        END;

        NextClass(Class,Tried);

    END; (* While not tried all page classes. *)

    ReportErrorPhrase(1);

    RETURN FALSE;
END MakeNewPage;
(*DOS>*)





















(*<DOS*)
PROCEDURE FindExistingRoomFor(     Size     : CARDINAL;
                                   Class    : APageClass;
                               VAR PageNo   : CARDINAL
                              ) : BOOLEAN;
VAR
    Page : APagePointer;
    Tried : AClassSet;
BEGIN
        (*<TRACE
    IF (Size > MaxRecordSize) THEN
        FatalError();
    END;
        TRACE>*)

        (* Can we find an existing page of this class with enough
           memory.  There are several reasons that might prevent us:
           1.  There are no pages of this class.
           2.  There are none with enough room.
           3.  It is not possible to add more pages of this class.
        *)

          (* Search this class for an availab     : AnExtStoragePreference;
    PageNo            : APageNo;
    RecNo, NewRecNo   : ARecordNo;
    CannotChangeSize  : BOOLEAN;
    HeapAddress       : ADDRESS;
(*DOS>*)
(*<OS2
    TempPtr           : ADDRESS;
    CopySize          : CARDINAL;
OS2>*)

BEGIN
(*<DOS*)
        (*<TRACE
    TraceHandleAndSize("SetExtSize",Handle,NewSize);
    TraceOff();
        TRACE>*)

        (*<TRACE
    IF ODD(NewSize) THEN
        TraceHandleAndSize("Odd-sized ",Handle,NewSize);
    END;
        TRACE>*)

        (* Get the page and record number. *)
    IF (NOT CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        RETURN FALSE;
    END;

    IF HandleIsLocked(Handle) THEN
        StorageError();
    END;

        (* Determine if we can move other records around, or
           whether we must keep other records in this page in
           place.  The test to allow the last record to always
           change size is important to prevent this routine
           from going into infinite recursion. *)

    CannotChangeSize := (Page^.Header.LockCount > 0)
                        AND
                        (RecNo+1 < Page^.Header.LastEntry);

    CurrentSize := SizeOfRecord(Page^,RecNo);

    ShiftLength := Page^.StartAt[Page^.Header.LastEntry]
                   - Page^.StartAt[RecNo+1];

        (* Move the other records in the array. *)

    IF (NewSize = CurrentSize) THEN
       (* Nothing *)

    ELSIF (NewSize > CurrentSize)     (* Bigger *)
       OR (CannotChangeSiz     : AnExtStoragePreference;
    PageNo            : APageNo;
    RecNo, NewRecNo   : ARecordNo;
    CannotChangeSize  : BOOLEAN;
    HeapAddress       : ADDRESS;
(*DOS>*)
(*<OS2
    TempPtr           : ADDRESS;
    CopySize          : CARDINAL;
OS2>*)

BEGIN
(*<DOS*)
        (*<TRACE
    TraceHandleAndSize("SetExtSize",Handle,NewSize);
    TraceOff();
        TRACE>*)

        (*<TRACE
    IF ODD(NewSize) THEN
        TraceHandleAndSize("Odd-sized ",Handle,NewSize);
    END;
        TRACE>*)

        (* Get the page and record number. *)
    IF (NOT CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        RETURN FALSE;
    END;

    IF HandleIsLocked(Handle) THEN
        StorageError();
    END;

        (* Determine if we can move other records around, or
           whether we must keep other records in this page in
           place.  The test to allow the last record to always
           change size is important to prevent this routine
           from going into infinite recursion. *)

    CannotChangeSize := (Page^.Header.LockCount > 0)
                        AND
                        (RecNo+1 < Page^.Header.LastEntry);

    CurrentSize := SizeOfRecord(Page^,RecNo);

    ShiftLength := Page^.StartAt[Page^.Header.LastEntry]
                   - Page^.StartAt[RecNo+1];

        (* Move the other records in the array. *)

    IF (NewSize = CurrentSize) THEN
       (* Nothing *)

    ELSIF (NewSize > CurrentSize)     (* Bigger *)
       OR (CannotChangeSize) THEN

        IF (NewSize > MaxDataBytesPerPage ) THEN
            RETURN FALSE;
        END;

        IF (NOT CannotChangeSize) THEN               (* Avoid cardinal overflow. *)
            Difference := NewSize - CurrentSize;
        END; 

        IF (CannotChangeSize) OR
           (SizeOfRecord(Page^,Page^.Header.LastEntry) < Difference) THEN

                (* Record won't fit on the current page, or the
                   current page is locked.  Force creation of a
                   new handle. *)

            StorageClass := AnExtStoragePreference(
                                PageTable^[Page^.Header.PageNumber].StorageClass);

                (* Our logic, here, relies on the assumption that
                   CreateExtObject will put the new record onto a page that
                   has enough room so that the new record can become
                   a copy of the original record without having to itself
                   be moved.  In this way, we avoid recursion. *)

            DecodeHandle(Handle,CellPointer,Gen);     (* Retain current generation. *)

                (* A: Make a copy of the original item on the heap. *)

            Size := LockObject(Handle,HeapAddress);

            IF (Size <> CurrentSize) THEN
                StorageError();
                RETURN FALSE;
            END;

                (* B: Make a new item that is the new size. *)
        
            IF ( NOT CreateExtObjectWithSize
                                        ( NewHandle,
                                          StorageClass,
                                          NewSize
                                         )) THEN
                StorageError();
                RETURN FALSE;
            END;

                (* C: Transfer from the heap copy of the old item to the
                      new page, new item. *)
        
                    (* There is a risk, here, that the NewSize is bigger than
                       the old size, sufficiently so that the copy could wrap
                       over a page boundary.  We don't really care that some
                       trash gets copied.  However, some processors (e.g. 80386)
                       may trap us if we try to read past the end of a page. *)
            
            IF (NewHandle <> NIL) AND
               (CheckAndDecodeHandle(NewHandle,NewPage,NewRecNo)) THEN
            
                INC(NewPage^.Header.LockCount);
            
                    (* Now copy the data into the record. *)
                IF (NewSize < Size) THEN
                    Size := NewSize;
                END;
                CopyBytes(HeapAddress,DataAddress(NewPage^,NewRecNo),Size);
                    (* The new handle takes on the Generation of the old handle. *)
                Page^.Generation[ RecNo ] := Gen;
                MarkPageDirty(NewPage^);
        
                DEC(NewPage^.Header.LockCount);
            ELSE
                StorageError();
            END;
            

                (* D: Take the original item out of the heap. *)
        
            ReleaseUnchangedObject(Handle);     (* Release our lock. *)
            PurgeFromCache(Handle,
                           FALSE (*WriteBack*) );
            
                (* E: Get rid of the original record from the page it
                      is in. *)

            IF (NOT CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
                RETURN FALSE;
            END;

            INC(Page^.Header.LockCount);  (* Lock Page into memory. *)

                (* Change the table that maps handles to pages and
                   records so that the old handle points to the
                   new record.   The old handle takes over the
                   identity of the new handle, but keeps the old
                   generation count. *)
            DecodeHandle(NewHandle,NewCellPointer,NewGen);
            CellPointer^ := NewCellPointer^;

            INC(PageTable^[ Page^.Header.PageNumber ].FreeBytes,
                CurrentSize );
            RemoveRecordFromPage(Page^,RecNo);
            DEC(Page^.Header.LockCount);  (* Free Page. *)
    
                (* Discard the (temporary) new handle's entry.  Cells
                   are marked as unused when their PageNo is 0.  *)
            NewCellPointer^.PageNo := 0C;

                (*<TRACE
            CheckSumTheCellTable();
                TRACE>*)
                
        ELSE
                (* Record does fit on the page. *)
            PurgeFromCache(Handle,
                           TRUE (*WriteBack*) );
            IF SetRecordSize(Page^,RecNo,NewSize) THEN
                PageNo := Page^.Header.PageNumber;
                DEC( PageTable^[PageNo].FreeBytes, NewSize - CurrentSize );
            ELSE
                StorageError();
            END; 
        END;

    ELSIF ( NewSize < CurrentSize ) THEN

            (* Record fits easily on the page because it has become smaller. *)

            (* Make sure that we do not have any copy of this record in
               the heap cache.  Transfer any heap copy back to its page. *)

        PurgeFromCache(Handle,TRUE (* WriteBack. *) );

        IF SetRecordSize(Page^,RecNo,NewSize) THEN
            PageNo := Page^.Header.PageNumber;
            INC( PageTable^[PageNo].FreeBytes, CurrentSize-NewSize );
        ELSE
            StorageError();
        END; 
    END;


        (*<TRACE
    TraceOn();
        TRACE>*)
(*DOS>*)

(*<OS2
    WITH Handle^ DO
        IF (NewSize = Size) THEN
            RETURN TRUE;
        ELSE
            IF (Available(NewSize)) THEN
                IF (NewSize <> 0) THEN
                    ALLOCATE(TempPtr, NewSize);

                    IF (NewSize < Size) THEN
                        CopySize := NewSize;
                    ELSE
                        CopySize := Size;
                    END;

                    CopyBytes(UserData, TempPtr, CopySize);
                END;

                 IF (Handle <> NIL) AND (CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        Size := SizeOfRecord(Page^,RecNo);
        RETURN Size;
    ELSE
        RETURN 0;
    END;
(*DOS>*)


(*<OS2
    RETURN Handle^.Size;
OS2>*)

END GetExtSize;




    (* HandleIsValid  -- Check whether this handle is a valid
                         handle or not.

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- If the handle was created by a successful
                         call to CreateExtObject and has not been
                         discarded, then TRUE is returned; else
                         FALSE.
    *)


PROCEDURE HandleIsValid  (     Handle : AnExtHandle ) : BOOLEAN;
VAR
(*<DOS*)
    Page     : APagePointer;
    RecNo    : ARecordNo;
    ok       : BOOLEAN;
(*DOS>*)
BEGIN
    IF (Handle = NIL) THEN
        RETURN FALSE;
    ELSE
(*<DOS*)
        ok := CheckAndDecodeHandle(Handle,Page,RecNo);
        IF (ok) THEN
                (*<TRACE
            TestCheckSums(Page^);
                TRACE>*)
        END;
        RETURN ok;
(*DOS>*)
(*<OS2
        RETURN TRUE;
OS2>*)
    END;
END HandleIsValid;




    (* Refresh --

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- Any storage on secondary media will match
                         any buffered copies of the data.

    *)

PROCEDURE Refresh();
(*<DOS*)
VAR
    Class : APageClass;
(*DOS>*)
BEGIN
(*<DOS*)
         : AnExtStoragePreference;
    PageNo            : APageNo;
    RecNo, NewRecNo   : ARecordNo;
    CannotChangeSize  : BOOLEAN;
    HeapAddress       : ADDRESS;
(*DOS>*)
(*<OS2
    TempPtr           : ADDRESS;
    CopySize          : CARDINAL;
OS2>*)

BEGIN
(*<DOS*)
        (*<TRACE
    TraceHandleAndSize("SetExtSize",Handle,NewSize);
    TraceOff();
        TRACE>*)

        (*<TRACE
    IF ODD(NewSize) THEN
        TraceHandleAndSize("Odd-sized ",Handle,NewSize);
    END;
        TRACE>*)

        (* Get the page and record number. *)
    IF (NOT CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        RETURN FALSE;
    END;

    IF HandleIsLocked(Handle) THEN
        StorageError();
    END;

        (* Determine if we can move other records around, or
           whether we must keep other records in this page in
           place.  The test to allow the last record to always
           change size is important to prevent this routine
           from going into infinite recursion. *)

    CannotChangeSize := (Page^.Header.LockCount > 0)
                        AND
                        (RecNo+1 < Page^.Header.LastEntry);

    CurrentSize := SizeOfRecord(Page^,RecNo);

    ShiftLength := Page^.StartAt[Page^.Header.LastEntry]
                   - Page^.StartAt[RecNo+1];

        (* Move the other records in the array. *)

    IF (NewSize = CurrentSize) THEN
       (* Nothing *)

    ELSIF (NewSize > CurrentSize)     (* Bigger *)
       OR (CannotChangeSize) THEN

        IF (NewSize > MaxDataBytesPerPage ) THEN
            RETURN FALSE;
        END;

        IF (NOT CannotChangeSize) THEN               (* Avoid cardinal overflow. *)
            Difference := NewSize - CurrentSize;
        END; 

        IF (CannotChangeSize) OR
           (SizeOfRecord(Page^,Page^.Header.LastEntry) < Difference) THEN

                (* Record won't fit on the current page, or the
                   current page is locked.  Force creation of a
                   new handle. *)

            StorageClass := AnExtStoragePreference(
                                PageTable^[Page^.Header.PageNumber].StorageClass);

                (* Our logic, here, relies on the assumption that
                   CreateExtObject will put the new record onto a page that
                   has enough room so that the new record can become
                   a copy of the original record without having to itself
                   be moved.  In this way, we avoid recursion. *)

            DecodeHandle(Handle,CellPointer,Gen);     (* Retain current generation. *)

                (* A: Make a copy of the original item on the heap. *)

            Size := LockObject(Handle,HeapAddress);

            IF (Size <> CurrentSize) THEN
                StorageError();
                RETURN FALSE;
            END;

                (* B: Make a new item that is the new size. *)
        
            IF ( NOT CreateExtObjectWithSize
                                        ( NewHandle,
                                          StorageClass,
                                          NewSize
                                         )) THEN
                StorageError();
                RETURN FALSE;
            END;

                (* C: Transfer from the heap copy of the old item to the
                      new page, new item. *)
        
                    (* There is a risk, here, that the NewSize is bigger than
                       the old size, sufficiently so that the copy could wrap
                       over a page boundary.  We don't really care that some
                       trash gets copied.  However, some processors (e.g. 80386)
                       may trap us if we try to read past the end of a page. *)
            
            IF (NewHandle <> NIL) AND
               (CheckAndDecodeHandle(NewHandle,NewPage,NewRecNo)) THEN
            
                INC(NewPage^.Header.LockCount);
            
                    (* Now copy the data into the record. *)
                IF (NewSize < Size) THEN
                    Size := NewSize;
                END;
                CopyBytes(HeapAddress,DataAddress(NewPage^,NewRecNo),Size);
                    (* The new handle takes on the Generation of the old handle. *)
                Page^.Generation[ RecNo ] := Gen;
                MarkPageDirty(NewPage^);
        
                DEC(NewPage^.Header.LockCount);
            ELSE
                StorageError();
            END;
            

                (* D: Take the original item out of the heap. *)
        
            ReleaseUnchangedObject(Handle);     (* Release our lock. *)
            PurgeFromCache(Handle,
                           FALSE (*WriteBack*) );
            
                (* E: Get rid of the original record from the page it
                      is in. *)

            IF (NOT CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
                RETURN FALSE;
            END;

            INC(Page^.Header.LockCount);  (* Lock Page into memory. *)

                (* Change the table that maps handles to pages and
                   records so that the old handle points to the
                   new record.   The old handle takes over the
                   identity of the new handle, but keeps the old
                   generation count. *)
            DecodeHandle(NewHandle,NewCellPointer,NewGen);
            CellPointer^ := NewCellPointer^;

            INC(PageTable^[ Page^.Header.PageNumber ].FreeBytes,
                CurrentSize );
            RemoveRecordFromPage(Page^,RecNo);
            DEC(Page^.Header.LockCount);  (* Free Page. *)
    
                (* Discard the (temporary) new handle's entry.  Cells
                   are marked as unused when their PageNo is 0.  *)
            NewCellPointer^.PageNo := 0C;

                (*<TRACE
            CheckSumTheCellTable();
                TRACE>*)
                
        ELSE
                (* Record does fit on the page. *)
            PurgeFromCache(Handle,
                           TRUE (*WriteBack*) );
            IF SetRecordSize(Page^,RecNo,NewSize) THEN
                PageNo := Page^.Header.PageNumber;
                DEC( PageTable^[PageNo].FreeBytes, NewSize - CurrentSize );
            ELSE
                StorageError();
            END; 
        END;

    ELSIF ( NewSize < CurrentSize ) THEN

            (* Record fits easily on the page because it has become smaller. *)

            (* Make sure that we do not have any copy of this record in
               the heap cache.  Transfer any heap copy back to its page. *)

        PurgeFromCache(Handle,TRUE (* WriteBack. *) );

        IF SetRecordSize(Page^,RecNo,NewSize) THEN
            PageNo := Page^.Header.PageNumber;
            INC( PageTable^[PageNo].FreeBytes, CurrentSize-NewSize );
        ELSE
            StorageError();
        END; 
    END;


        (*<TRACE
    TraceOn();
        TRACE>*)
(*DOS>*)

(*<OS2
    WITH Handle^ DO
        IF (NewSize = Size) THEN
            RETURN TRUE;
        ELSE
            IF (Available(NewSize)) THEN
                IF (NewSize <> 0) THEN
                    ALLOCATE(TempPtr, NewSize);

                    IF (NewSize < Size) THEN
                        CopySize := NewSize;
                    ELSE
                        CopySize := Size;
                    END;

                    CopyBytes(UserData, TempPtr, CopySize);
                END;

                 IF (Handle <> NIL) AND (CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        Size := SizeOfRecord(Page^,RecNo);
        RETURN Size;
    ELSE
        RETURN 0;
    END;
(*DOS>*)


(*<OS2
    RETURN Handle^.Size;
OS2>*)

END GetExtSize;




    (* HandleIsValid  -- Check whether this handle is a valid
                         handle or not.

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- If the handle was created by a successful
                         call to CreateExtObject and has not been
                         discarded, then TRUE is returned; else
                         FALSE.
    *)


PROCEDURE HandleIsValid  (     Handle : AnExtHandle ) : BOOLEAN;
VAR
(*<DOS*)
    Page     : APagePointer;
    RecNo    : ARecordNo;
    ok       : BOOLEAN;
(*DOS>*)
BEGIN
    IF (Handle = NIL) THEN
        RETURN FALSE;
    ELSE
(*<DOS*)
        ok := CheckAndDecodeHandle(Handle,Page,RecNo);
        IF (ok) THEN
                (*<TRACE
            TestCheckSums(Page^);
                TRACE>*)
        END;
        RETURN ok;
(*DOS>*)
(*<OS2
        RETURN TRUE;
OS2>*)
    END;
END HandleIsValid;




    (* Refresh --

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- Any storage on secondary media will match
                         any buffered copies of the data.

    *)

PROCEDURE Refresh();
(*<DOS*)
VAR
    Class : APageClass;
(*DOS>*)
BEGIN
(*<DOS*)
     IF (Handle <> NIL) AND (CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        Size := SizeOfRecord(Page^,RecNo);
        RETURN Size;
    ELSE
        RETURN 0;
    END;
(*DOS>*)


(*<OS2
    RETURN Handle^.Size;
OS2>*)

END GetExtSize;




    (* HandleIsValid  -- Check whether this handle is a valid
                         handle or not.

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- If the handle was created by a successful
                         call to CreateExtObject and has not been
                         discarded, then TRUE is returned; else
                         FALSE.
    *)


PROCEDURE HandleIsValid  (     Handle : AnExtHandle ) : BOOLEAN;
VAR
(*<DOS*)
    Page     : APagePointer;
    RecNo    : ARecordNo;
    ok       : BOOLEAN;
(*DOS>*)
BEGIN
    IF (Handle = NIL) THEN
        RETURN FALSE;
    ELSE
(*<DOS*)
        ok := CheckAndDecodeHandle(Handle,Page,RecNo);
        IF (ok) THEN
                (*<TRACE
            TestCheckSums(Page^);
                TRACE>*)
        END;
        RETURN ok;
(*DOS>*)
(*<OS2
        RETURN TRUE;
OS2>*)
    END;
END HandleIsValid;




    (* Refresh --

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- Any storage on secondary media will match
                         any buffered copies of the data.

    *)

PROCEDURE Refresh();
(*<DOS*)
VAR
    Class : APageClass;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    Trace("Refresh");
        TRACE>*)


    FOR Class := PageFast TO PageSlow DO
        IF (ClassPageSize[Class] > 0) AND (NOT SynchPage(Class)) THEN
            StorageError();
        END;
    END;
(*DOS>*)
END Refresh;





    (*$R-*) (*$S-*) (*$T-*)


PROCEDURE HandleIsLocked( Handle : AnExtHandle ) : BOOLEAN;
VAR
(*<DOS*)
    i : CARDINAL;
    Found : BOOLEAN;
(*DOS>*)
BEGIN
(*<DOS*)
    IF LocateRecordIndex(Handle,i) AND
       (HashRecords[i].Locks > 0) THEN
        RETURN TRUE;
    END;
(*DOS>*)
    RETURN FALSE;
END HandleIsLocked;





    (*$R=*) (*$S=*) (*$T=*)






    (* CopyObject --

       Preconditions  -- InitExtStorage must have been called.
                         OriginalHandle is not NIL.

       Postconditions -- A valid handle will be created.  It will refer
                         to a new extended storage block that is a
                         bitwise copy of the original's data block.
                         Storage is duplicated.
                         Or else, FALSE will be returned.

    *)

PROCEDURE CopyObject     (     OriginalHandle : AnExtHandle;
                           VAR NewHandle      : AnExtHandle;
                               NewSize        : CARDINAL;
                               NewStorage     : AnExtStoragePreference
                          ):BOOLEAN;
VAR
(*<DOS*)
    OldHandle  : AnExtHandle;
    CellNo     : ACellNo;
    PageNum    : APageNo;
    Page       : APagePointer;
    V          : BOOLEAN;
    RecNo      : ARecordNo;
    HeapAddress : ADDRESS;
    Size       : CARDINAL;
(*DOS>*)

BEGIN
(*<DOS*)
    OldHandle := OriginalHandle;  (* In case Original and New are same var. *)

        (*<TRACE
    TraceHandleAndSize("CopyObject",OldHandle,NewSize);
        TRACE>*)

    Size := LockObject(OldHandle,HeapAddress);

    V := FALSE;

    IF ( CreateExtObjectWithSize
                        ( NewHandle,
                          NewStorage,
                          NewSize
                         )) THEN

                (* There is a risk, here, that the NewSize is bigger than
                   the old size, sufficiently so that the copy could wrap
                   over a page boundary.  We don't really care that some
                   trash gets copied.  However, some processors (e.g. 80386)
                   may trap us if we try to read past the end of a page. *)
    
        IF (NewHandle <> NIL) AND
           (CheckAndDecodeHandle(NewHandle,Page,RecNo)) THEN
    
            INC(Page^.Header.LockCount);
    
                (* Now copy the data into the record. *)
            IF (NewSize < Size) THEN
                Size := NewSize;
            END;
            IF (Size > 0) THEN
                CopyBytes(HeapAddress,DataAddress(Page^,RecNo),Size);
            END;
            MarkPageDirty(Page^);
            V := TRUE;

            DEC(Page^.Header.LockCount);
        ELSE
            StorageError();
        END;
    END;

    ReleaseUnchangedObject(OldHandle);     (* Release our lock. *)


    RETURN V;
(*DOS>*)

(*<OS2
    RETURN (CreateExtObjectWithSize( NewHandle, NewStorage, NewSize ) AND
            SetExtData( NewHandle, OriginalHandle^.UserData, NewSize ));
OS2>*)

END CopyObject;








    (* CopyExtObject --

       Preconditions  -- InitExtStorage must have been called.

       Postconditions -- A valid handle will be created.  It will refer
                         to a new extended storage block that is a
                         bitwise copy of the original's data block.
                         Or else, FALSE will be returned.

    *)

PROCEDURE CopyExtObject  (     OriginalHandle : AnExtHandle;
                               NewStorage     : AnExtStoragePreference;
                           VAR NewHandle      : AnExtHandle
                          ):BOOLEAN;
VAR
    OldHandle  : AnExtHandle;
(*<DOS*)
    CellNo     : ACellNo;
    PageNum    : APageNo;
    Page       : APagePointer;
    V          : BOOLEAN;
    RecNo      : ARecordNo;
(*DOS>*)

BEGIN
    OldHandle := OriginalHandle;   (* In case NewHandle == OriginalHandle. *)
(*<DOS*)
        (*<TRACE
    TraceHandle("CopyExtObject",OldHandle);
    TraceOff();
        TRACE>*)


    NewHandle := NIL;
    IF OldHandle = NIL THEN
            (*<TRACE
       TraceOn();
            TRACE>*)
       RETURN TRUE;
    END;

    IF (NOT CheckAndDecodeHandle(OldHandle,Page,RecNo)) THEN
        StorageError();
    END;

    IF (CopyObject(OldHandle,NewHandle,
                       SizeOfRecord(Page^,RecNo),NewStorage)) THEN
        INC(Quantity);
            (*<TRACE
        TraceOn();
        TraceHandle("  Copied to",NewHandle);
            TRACE>*)

        RETURN TRUE;
    END;

        (*<TRACE
   TraceOn();
        TRACE>*)

    RETURN FALSE;
(*DOS>*)

(*<OS2
    RETURN (CreateExtObjectWithSize( NewHandle, NewStorage, OldHandle^.Size ) AND
            SetExtData( NewHandle, OldHandle^.UserData, OldHandle^.Size ));
OS2>*)

END CopyExtObject;













    (* GetExtStoragePreference --

       Preconditions  -- The handle must have been created by a 
                         sucessfull call to CreateExtObject, and not
                         discarded.

       Postconditions --
                         The current storage preference is set.
     *)

PROCEDURE GetExtStoragePreference  (     Handle : AnExtHandle )
                                     : AnExtStoragePreference;
VAR
(*<DOS*)
    Cell       : ACellPointer; 
    Gen        : AGeneration;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    TraceHandle("GetExtStoragePreference",Handle);
        TRACE>*)

    DecodeHandle(Handle,Cell,Gen);

    RETURN AnExtStoragePreference( PageTable^[ ORD(Cell^.PageNo) ].StorageClass ); 
(*DOS>*)

(*<OS2
    RETURN ExtFast;
OS2>*)

END GetExtStoragePreference;



PROCEDURE SetExtStoragePreference  (     Handle  : AnExtHandleeHandle("ReleaseObject",Handle);
        TRACE>*)


    IF (Handle = NIL) THEN
        RETURN;
    END;

        (* If we have kept a copy on the heap, release it. *)

    IF (LocateRecordIndex(Handle,i)) THEN
        (*$R-*) INC(Clock); (*$R=*)     (* Allow overflow. *)
        WITH HashRecords[i] DO
            IF (Locks > 0) THEN         (* Allow unlock of unlocked item. *)
                DEC(Locks);
                (*<STATISTICS*)
                IF (Locks = 0) THEN
                    LockedBytesInMemory := LockedBytesInMemory - VAL(LONGINT,Size);
                END;
                DEC(OutstandingLocks);
                (*STATISTICS>*)
                Time := Clock;
                Dirty := TRUE;
            END;
        END;
    ELSE
        StorageError();
    END;

(*DOS>*)

END XReleaseObject;


    (*$R=*) (*$S=*) (*$T=*)




    (*$R-*) (*$S-*) (*$T-*)


    (* ReleaseUnchangedObject - Release previously locked object.

       Preconditions  -- The object must have been locked.
                         (If not, StorageError is called).

       Postconditions -- The object is unlocked, and not marked as dirty.

    *)




PROCEDURE XReleaseUnchangedObject(    Handle : AnExtHandle );

(*<DOS*)
VAR
    i         : CARDINAL;
    Page     : APagePointer;
    RecNo    : ARecordNo;
    Found    : BOOLEAN;
(*DOS>*)
BEGIN                       (* XReleaseUnchangedObject *)
(*<DOS*)

        (*<TRACE
    TraceHandle("ReleaseUnchangedObject", IF (Handle <> NIL) AND (CheckAndDecodeHandle(Handle,Page,RecNo)) THEN
        Size := SizeOfRecord(Page^,RecNo);
        RETURN Size;
    ELSE
        RETURN 0;
    END;
(*DOS>*)


(*<OS2
    RETURN Handle^.Size;
OS2>*)

END GetExtSize;




    (* HandleIsValid  -- Check whether this handle is a valid
                         handle or not.

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- If the handle was created by a successful
                         call to CreateExtObject and has not been
                         discarded, then TRUE is returned; else
                         FALSE.
    *)


PROCEDURE HandleIsValid  (     Handle : AnExtHandle ) : BOOLEAN;
VAR
(*<DOS*)
    Page     : APagePointer;
    RecNo    : ARecordNo;
    ok       : BOOLEAN;
(*DOS>*)
BEGIN
    IF (Handle = NIL) THEN
        RETURN FALSE;
    ELSE
(*<DOS*)
        ok := CheckAndDecodeHandle(Handle,Page,RecNo);
        IF (ok) THEN
                (*<TRACE
            TestCheckSums(Page^);
                TRACE>*)
        END;
        RETURN ok;
(*DOS>*)
(*<OS2
        RETURN TRUE;
OS2>*)
    END;
END HandleIsValid;




    (* Refresh --

       Preconditions  -- InitExtStorage must have returned TRUE.

       Postconditions -- Any storage on secondary media will match
                         any buffered copies of the data.

    *)

PROCEDURE Refresh();
(*<DOS*)
VAR
    Class : APageClass;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    Trace("Refresh");
        TRACE>*)


    FOR Class := PageFast TO PageSlow DO
        IF (ClassPageSize[Class] > 0) AND (NOT SynchPage(Class)) THEN
            StorageError();
        END;
    END;
(*DOS>*)
END Refresh;





    (*$R-*) (*$S-*) (*$T-*)


PROCEDURE HandleIsLocked( Handle : AnExtHandle ) : BOOLEAN;
VAR
(*<DOS*)
    i : CARDINAL;
    Found : BOOLEAN;
(*DOS>*)
BEGIN
(*<DOS*)
    IF LocateRecordIndex(Handle,i) AND
       (HashRecords[i].Locks > 0) THEN
        RETURN TRUE;
    END;
(*DOS>*)
    RETURN FALSE;
END HandleIsLocked;





    (*$R=*) (*$S=*) (*$T=*)






    (* CopyObject --

       Preconditions  -- InitExtStorage must have been called.
                         OriginalHandle is not NIL.

       Postconditions -- A valid handle will be created.  It will refer
                         to a new extended storage block that is a
                         bitwise copy of the original's data block.
                         Storage is duplicated.
                         Or else, FALSE will be returned.

    *)

PROCEDURE CopyObject     (     OriginalHandle : AnExtHandle;
                           VAR NewHandle      : AnExtHandle;
                               NewSize        : CARDINAL;
                               NewStorage     : AnExtStoragePreference
                          ):BOOLEAN;
VAR
(*<DOS*)
    OldHandle  : AnExtHandle;
    CellNo     : ACellNo;
    PageNum    : APageNo;
    Page       : APagePointer;
    V          : BOOLEAN;
    RecNo      : ARecordNo;
    HeapAddress : ADDRESS;
    Size       : CARDINAL;
(*DOS>*)

BEGIN
(*<DOS*)
    OldHandle := OriginalHandle;  (* In case Original and New are same var. *)

        (*<TRACE
    TraceHandleAndSize("CopyObject",OldHandle,NewSize);
        TRACE>*)

    Size := LockObject(OldHandle,HeapAddress);

    V := FALSE;

    IF ( CreateExtObjectWithSize
                        ( NewHandle,
                          NewStorage,
                          NewSize
                         )) THEN

                (* There is a risk, here, that the NewSize is bigger than
                   the old size, sufficiently so that the copy could wrap
                   over a page boundary.  We don't really care that some
                   trash gets copied.  However, some processors (e.g. 80386)
                   may trap us if we try to read past the end of a page. *)
    
        IF (NewHandle <> NIL) AND
           (CheckAndDecodeHandle(NewHandle,Page,RecNo)) THEN
    
            INC(Page^.Header.LockCount);
    
                (* Now copy the data into the record. *)
            IF (NewSize < Size) THEN
                Size := NewSize;
            END;
            IF (Size > 0) THEN
                CopyBytes(HeapAddress,DataAddress(Page^,RecNo),Size);
            END;
            MarkPageDirty(Page^);
            V := TRUE;

            DEC(Page^.Header.LockCount);
        ELSE
            StorageError();
        END;
    END;

    ReleaseUnchangedObject(OldHandle);     (* Release our lock. *)


    RETURN V;
(*DOS>*)

(*<OS2
    RETURN (CreateExtObjectWithSize( NewHandle, NewStorage, NewSize ) AND
            SetExtData( NewHandle, OriginalHandle^.UserData, NewSize ));
OS2>*)

END CopyObject;








    (* CopyExtObject --

       Preconditions  -- InitExtStorage must have been called.

       Postconditions -- A valid handle will be created.  It will refer
                         to a new extended storage block that is a
                         bitwise copy of the original's data block.
                         Or else, FALSE will be returned.

    *)

PROCEDURE CopyExtObject  (     OriginalHandle : AnExtHandle;
                               NewStorage     : AnExtStoragePreference;
                           VAR NewHandle      : AnExtHandle
                          ):BOOLEAN;
VAR
    OldHandle  : AnExtHandle;
(*<DOS*)
    CellNo     : ACellNo;
    PageNum    : APageNo;
    Page       : APagePointer;
    V          : BOOLEAN;
    RecNo      : ARecordNo;
(*DOS>*)

BEGIN
    OldHandle := OriginalHandle;   (* In case NewHandle == OriginalHandle. *)
(*<DOS*)
        (*<TRACE
    TraceHandle("CopyExtObject",OldHandle);
    TraceOff();
        TRACE>*)


    NewHandle := NIL;
    IF OldHandle = NIL THEN
            (*<TRACE
       TraceOn();
            TRACE>*)
       RETURN TRUE;
    END;

    IF (NOT CheckAndDecodeHandle(OldHandle,Page,RecNo)) THEN
        StorageError();
    END;

    IF (CopyObject(OldHandle,NewHandle,
                       SizeOfRecord(Page^,RecNo),NewStorage)) THEN
        INC(Quantity);
            (*<TRACE
        TraceOn();
        TraceHandle("  Copied to",NewHandle);
            TRACE>*)

        RETURN TRUE;
    END;

        (*<TRACE
   TraceOn();
        TRACE>*)

    RETURN FALSE;
(*DOS>*)

(*<OS2
    RETURN (CreateExtObjectWithSize( NewHandle, NewStorage, OldHandle^.Size ) AND
            SetExtData( NewHandle, OldHandle^.UserData, OldHandle^.Size ));
OS2>*)

END CopyExtObject;













    (* GetExtStoragePreference --

       Preconditions  -- The handle must have been created by a 
                         sucessfull call to CreateExtObject, and not
                         discarded.

       Postconditions --
                         The current storage preference is set.
     *)

PROCEDURE GetExtStoragePreference  (     Handle : AnExtHandle )
                                     : AnExtStoragePreference;
VAR
(*<DOS*)
    Cell       : ACellPointer; 
    Gen        : AGeneration;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    TraceHandle("GetExtStoragePreference",Handle);
        TRACE>*)

    DecodeHandle(Handle,Cell,Gen);

    RETURN AnExtStoragePreference( PageTable^[ ORD(Cell^.PageNo) ].StorageClass ); 
(*DOS>*)

(*<OS2
    RETURN ExtFast;
OS2>*)

END GetExtStoragePreference;



PROCEDURE SetExtStoragePreference  (     Handle  : AnExtHandleect - Release previously locked object.

       Preconditions  -- The object must have been locked.
                         (If not, StorageError is called).

       Postconditions -- The object is unlocked.

    *)




PROCEDURE XReleaseObject(    Handle : AnExtHandle );
(*<DOS*)
VAR
    i         : CARDINAL;
    Page      : APagePointer;
    RecNo     : ARecordNo;
    Found     : BOOLEAN;
(*DOS>*)
BEGIN                       (* XReleaseObject *)
(*<DOS*)

        (*<TRACE
    TraceHandle("ReleaseObject",Handle);
        TRACE>*)


    IF (Handle = NIL) THEN
        RETURN;
    END;

        (* If we have kept a copy on the heap, release it. *)

    IF (LocateRecordIndex(Handle,i)) THEN
        (*$R-*) INC(Clock); (*$R=*)     (* Allow overflow. *)
        WITH HashRecords[i] DO
            IF (Locks > 0) THEN         (* Allow unlock of unlocked item. *)
                DEC(Locks);
                (*<STATISTICS*)
                IF (Locks = 0) THEN
                    LockedBytesInMemory := LockedBytesInMemory - VAL(LONGINT,Size);
                END;
                DEC(OutstandingLocks);
                (*STATISTICS>*)
                Time := Clock;
                Dirty := TRUE;
            END;
        END;
    ELSE
        StorageError();
    END;

(*DOS>*)

END XReleaseObject;


    (*$R=*) (*$S=*) (*$T=*)




    (*$R-*) (*$S-*) (*$T-*)


    (* ReleaseUnchangedObject - Release previously locked object.

       Preconditions  -- The object - Release previously locked object.

       Preconditions  -- The object must have been locked.
                         (If not, StorageError is called).

       Postconditions -- The object is unlocked.

    *)




PROCEDURE XReleaseObject(    Handle : AnExtHandle );
(*<DOS*)
VAR
    i         : CARDINAL;
    Page      : APagePointer;
    RecNo     : ARecordNo;
    Found     : BOOLEAN;
(*DOS>*)
BEGIN                       (* XReleaseObject *)
(*<DOS*)

        (*<TRACE
    TraceHandle("ReleaseObject",Handle);
        TRACE>*)


    IF (Handle = NIL) THEN
        RETURN;
    END;

        (* If we have kept a copy on the heap, release it. *)

    IF (LocateRecordIndex(Handle,i)) THEN
        (*$R-*) INC(Clock); (*$R=*)     (* Allow overflow. *)
        WITH HashRecords[i] DO
            IF (Locks > 0) THEN         (* Allow unlock of unlocked item. *)
                DEC(Locks);
                (*<STATISTICS*)
                IF (Locks = 0) THEN
                    LockedBytesInMemory := LockedBytesInMemory - VAL(LONGINT,Size);
                END;
                DEC(OutstandingLocks);
                (*STATISTICS>*)
                Time := Clock;
                Dirty := TRUE;
            END;
        END;
    ELSE
        StorageError();
    END;

(*DOS>*)

END XReleaseObject;


    (*$R=*) (*$S=*) (*$T=*)




    (*$R-*) (*$S-*) (*$T-*)


    (* ReleaseUnchangedObject - Release previously locked object.

       Preconditions  -- The object must have been locked.
                         (If not, StorageError is called).

       Postconditions -- The object is unlocked, and not marked as dirty.

    *)




PROCEDURE XReleaseUnchangedObject(    Handle : AnExtHandle );

(*<DOS*)
VAR
    i         : CARDINAL;
    Page     : APagePointer;
    RecNo    : ARecordNo;
    Found    : BOOLEAN;
(*DOS>*)
BEGIN                       (* XReleaseUnchangedObject *)
(*<DOS*)

        (*<TRACE
    TraceHandle("ReleaseUnchangedObject",Handle);
        TRACE>*)

    IF (Handle = NIL) THEN
        RETURN;
    END;


        (* If we have kept a copy on the heap, release it. *)

    IF (LocateRecordIndex(Handle,i)) THEN
        (*$R-*) INC(Clock); (*$R=*)     (* Allow overflow. *)
        WITH HashRecords[i] DO
            IF (Locks > 0) THEN         (* Allow unlock of unlocked item. *)
                DEC(Locks);
                (*<STATISTICS*)
                IF (Locks = 0) THEN
                    LockedBytesInMemory := LockedBytesInMemory - VAL(LONGINT,Size);
                END;
                DEC(OutstandingLocks);
                (*STATISTICS>*)
                Time := Clock;
                (* Note that we do not mark the item dirty. *)
            END;
        END;
    ELSE
        StorageError();
    END;

(*DOS>*)


END XReleaseUnchangedObject;


    (*$R=*) (*$S=*) (*$T=*)









        (* ArraySize -- Returns the true size taken up by an array of records.
                    This accounts for odd length records.

       Preconditions  -- # of records in the array, size of one record
                         (From TSIZE/SIZE).

       Postconditions -- Returns # of bytes in the full array.  
    *)


PROCEDURE ObjectsAreSame( HandleA, HandleB : AnExtHandle ) : BOOLEAN;
BEGIN
        (*<TRACE
    TraceHandle("ObjectsAreSame",HandleA);
        TRACE>*)


    RETURN (HandleA = HandleB);
END ObjectsAreSame;





    (* TerminateExtStorage --

       Preconditions:
           InitExtStorage returned TRUE.
           TerminateExtStorage has not been called.

       Postconditions:
           Storage held by this module is released.

    *)

PROCEDURE TerminateExtStorage();
(*<DOS*)
VAR
    i : CARDINAL;
    Block : ACellBlockNumber;
    Class : APageClass;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    Trace("TerminateExtStorage");
        TRACE>*)


    (*
        (* Copy extended data to secondary media. *)
        (* Why bother? *)

    Refresh();

    FOR i := 1 TO MaxPages DO
        WITH PageTable^[i] DO
            IF (Valid) THEN
                Valid := NOT DiscardPage(StorageClass,HomeAddress);
            END;
        END;
    END;
    *)

    FOR Class := PageFast TO PageSlow DO
        IF (ClassPageSize[Class] > 0) THEN
            ShutdownPageClass(Class);
        END;
    END;

    FOR Block := 0C TO TopCellBlock DO
        DISPOSE(CellBlockTable[Block]);
    END;
(*DOS>*)
END TerminateExtStorage;




(*<DOS*)

PROCEDURE CreateCellBlock( i : ACellBlockNumber ) : BOOLEAN;
VAR
    CellNo : ACellNo;
BEGIN
    IF (Available(TSIZE(ACellBlock))) THEN
        NEW(CellBlockTable[i]);
        FOR CellNo := 0C TO MaxCellPerBlock DO
            WITH CellBlockTable[i]^[CellNo] DO
                PageNo     := 0C;       (* Not a page *)
            END;
        END;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END;
END CreateCellBlock;

(*DOS>*)



(* RSC 21-Aug-89  Modified to return queazy if we are low on FlexStor.
*)
PROCEDURE GetExtStatus():AnExtStatus;
(*<DOS*)
CONST
    DesiredFreeKForReasonableness = 64;
VAR
    KFree,
    KNeededForReason,
    WorstCondition,
    Condition       : CARDINAL;
    Class           : APageClass;
    ClassStatus     : APageClassStatus;
(*DOS>*)
BEGIN
(*<DOS*)
    KNeededForReason := DesiredFreeKForReasonableness;

    IF (Interlock > 0) THEN
        WorstCondition := 2;     (* Reentrancy lockout. *)        (* 25-Sep-89 LAA *)
    ELSE
        WorstCondition := 0;
    END; 
    FOR Class := PageFast TO PageSlow DO
        IF (ClassPageSize[Class] > 0) THEN
            PageClassStatus(Class,ClassStatus);
            Condition := ClassStatus.Condition;
            IF (Condition > WorstCondition) THEN
                WorstCondition := Condition;
            END;
            IF (Class <> PageFast) THEN
                KFree := ClassStatus.FreePages * (ClassPageSize[Class] DIV 1024);
                IF (KNeededForReason > KFree) THEN
                    DEC( KNeededForReason, KFree );
                ELSE
                    KNeededForReason := 0;
                END;
            END;
        END;
    END;

    (* 21-Aug-89 RSC  If there is not enough free space to satisfy us,
                      then make us queazy.
    *)
    IF (WorstCondition = 0) AND
       (KNeededForReason > 0) THEN
        WorstCondition := 1;
    END;

    RETURN VAL(AnExtStatus,WorstCondition);
(*DOS>*)

(*<OS2
    RETURN ExtGood;
OS2>*)
END GetExtStatus;










PROCEDURE InitFlexStor();
VAR
    InitIndex          : CARDINAL;
(*<DOS*)
    Class              : APageClass;
(*DOS>*)
BEGIN
        (* Initialize the FlexData module before using it. *)
    InitFlexData();

(*<DOS*)

       (* Our calculations of array sizes assume that the compiler
          pads array elements to start on an even offset boundary. *)
    IF (TSIZE(TwoOddSizedRecords) <> (TSIZE(AnOddSizedRecord)+1)*2 ) THEN
        StorageError();
    END;

    Quantity  := 0;
    Interlock := 0; 
(*DOS>*)
    FOR InitIndex := 1 TO MaxPages DO
        PageTable^[InitIndex].Valid := FALSE;
    END;

(*<DOS*)
    FOR InitIndex := 0 TO ORD(HIGH(CellBlockTable)) DO
        CellBlockTable[CHR(InitIndex)] := NIL;
    END;

    TopCellBlock := 0C;
    IF (NOT CreateCellBlock(0C)) THEN StorageError(); END;

    FOR Class := PageFast TO PageSlow DO
        ClassPageSize[ Class ] := 0;
        LastPageAdded[ Class ] := 1;
        LotFSET + A.SEGMENT) MOD HashTableSize;
END Hash;

(*$S=*) (*$R=*) (*T=*)


PROCEDURE Search(     TheHandle : AnExtHandle;
                  VAR HashTableIndex : CARDINAL;
                  VAR HashRecordIndex : CARDINAL  ) : BOOLEAN;
BEGIN
    HashTableIndex := Hash(TheHandle);
        (* Get the top of the chain. *)
    HashRecordIndex := HashTable[ HashTableIndex ];
        (* Search the chain for the record with the Handle in it. *)
    WHILE (HashRecordIndex <> Null) DO
        WITH HashRec;
VAR
    HashTableIndex : CARDINAL;
BEGIN
    RETURN Search(Handle,HashTableIndex,HashRecordIndex);
END LocateRecordIndex;



PROCEDURE AddToTable( TheHandle : AnExtHandle; VAR i : CARDINAL ):BOOLEAN;
VAR
    HashTableIndex : CARDINAL;
BEGIN
    IF NOT Search(TheHandle,HashTableIndex,i) THEN
            (* Get a new HashRecord. *)
        i := UnusedRecords;
        IF (i <> Null) THEN
            UnusedRecords := HashRecords[ UnusedRecords ].Next;
        ELSE
            (* No empty space. *)
            RETURN FALSE;
        END;
        WITH HashRecords[ i ] DO
                (* Fill in the handle. *)
            Handle := TheHandle;
                (* Link to table. *)
            Next   := HashTable[ HashTableIndex ];
        END;
        HashTable[ HashTableIndex ] := i;
        RETURN TRUE;
    END;

    RETURN FALSE;
END AddToTable;


    (* Removes Handle from the hash tables. *)

PROCEDURE RemoveFromTable( TheHandle : AnExtHandle );
VAR
    i, Last,HashRecoect - Release previously locked object.

       Preconditions  -- The object must have been locked.
                         (If not, StorageError is called).

       Postconditions -- The object is unlocked.

    *)




PROCEDURE XReleaseObject(    Handle : AnExtHandle );
(*<DOS*)
VAR
    i         : CARDINAL;
    Page      : APagePointer;
    RecNo     : ARecordNo;
    Found     : BOOLEAN;
(*DOS>*)
BEGIN                       (* XReleaseObject *)
(*<DOS*)

        (*<TRACE
    TraceHandle("ReleaseObject",Handle);
        TRACE>*)


    IF (Handle = NIL) THEN
        RETURN;
    END;

        (* If we have kept a copy on the heap, release it. *)

    IF (LocateRecordIndex(Handle,i)) THEN
        (*$R-*) INC(Clock); (*$R=*)     (* Allow overflow. *)
        WITH HashRecords[i] DO
            IF (Locks > 0) THEN         (* Allow unlock of unlocked item. *)
                DEC(Locks);
                (*<STATISTICS*)
                IF (Locks = 0) THEN
                    LockedBytesInMemory := LockedBytesInMemory - VAL(LONGINT,Size);
                END;
                DEC(OutstandingLocks);
                (*STATISTICS>*)
                Time := Clock;
                Dirty := TRUE;
            END;
        END;
    ELSE
        StorageError();
    END;

(*DOS>*)

END XReleaseObject;


    (*$R=*) (*$S=*) (*$T=*)




    (*$R-*) (*$S-*) (*$T-*)


    (* ReleaseUnchangedObject - Release previously locked object.

       Preconditions  -- The object must have been locked.
                         (If not, StorageError is called).

       Postconditions -- The object is unlocked, and not marked as dirty.

    *)




PROCEDURE XReleaseUnchangedObject(    Handle : AnExtHandle );

(*<DOS*)
VAR
    i         : CARDINAL;
    Page     : APagePointer;
    RecNo    : ARecordNo;
    Found    : BOOLEAN;
(*DOS>*)
BEGIN                       (* XReleaseUnchangedObject *)
(*<DOS*)

        (*<TRACE
    TraceHandle("ReleaseUnchangedObject",Handle);
        TRACE>*)

    IF (Handle = NIL) THEN
        RETURN;
    END;


        (* If we have kept a copy on the heap, release it. *)

    IF (LocateRecordIndex(Handle,i)) THEN
        (*$R-*) INC(Clock); (*$R=*)     (* Allow overflow. *)
        WITH HashRecords[i] DO
            IF (Locks > 0) THEN         (* Allow unlock of unlocked item. *)
                DEC(Locks);
                (*<STATISTICS*)
                IF (Locks = 0) THEN
                    LockedBytesInMemory := LockedBytesInMemory - VAL(LONGINT,Size);
                END;
                DEC(OutstandingLocks);
                (*STATISTICS>*)
                Time := Clock;
                (* Note that we do not mark the item dirty. *)
            END;
        END;
    ELSE
        StorageError();
    END;

(*DOS>*)


END XReleaseUnchangedObject;


    (*$R=*) (*$S=*) (*$T=*)









        (* ArraySize -- Returns the true size taken up by an array of records.
                    This accounts for odd length records.

       Preconditions  -- # of records in the array, size of one record
                         (From TSIZE/SIZE).

       Postconditions -- Returns # of bytes in the full array.  
    *)


PROCEDURE ObjectsAreSame( HandleA, HandleB : AnExtHandle ) : BOOLEAN;
BEGIN
        (*<TRACE
    TraceHandle("ObjectsAreSame",HandleA);
        TRACE>*)


    RETURN (HandleA = HandleB);
END ObjectsAreSame;





    (* TerminateExtStorage --

       Preconditions:
           InitExtStorage returned TRUE.
           TerminateExtStorage has not been called.

       Postconditions:
           Storage held by this module is released.

    *)

PROCEDURE TerminateExtStorage();
(*<DOS*)
VAR
    i : CARDINAL;
    Block : ACellBlockNumber;
    Class : APageClass;
(*DOS>*)
BEGIN
(*<DOS*)
        (*<TRACE
    Trace("TerminateExtStorage");
        TRACE>*)


    (*
        (* Copy extended data to secondary media. *)
        (* Why bother? *)

    Refresh();

    FOR i := 1 TO MaxPages DO
        WITH PageTable^[i] DO
            IF (Valid) THEN
                Valid := NOT DiscardPage(StorageClass,HomeAddress);
            END;
        END;
    END;
    *)

    FOR Class := PageFast TO PageSlow DO
        IF (ClassPageSize[Class] > 0) THEN
            ShutdownPageClass(Class);
        END;
    END;

    FOR Block := 0C TO TopCellBlock DO
        DISPOSE(CellBlockTable[Block]);
    END;
(*DOS>*)
END TerminateExtStorage;




(*<DOS*)

PROCEDURE CreateCellBlock( i : ACellBlockNumber ) : BOOLEAN;
VAR
    CellNo : ACellNo;
BEGIN
    IF (Available(TSIZE(ACellBlock))) THEN
        NEW(CellBlockTable[i]);
        FOR CellNo := 0C TO MaxCellPerBlock DO
            WITH CellBlockTable[i]^[CellNo] DO
                PageNo     := 0C;       (* Not a page *)
            END;
        END;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END;
END CreateCellBlock;

(*DOS>*)



(* RSC 21-Aug-89  Modified to return queazy if we are low on FlexStor.
*)
PROCEDURE GetExtStatus():AnExtStatus;
(*<DOS*)
CONST
    DesiredFreeKForReasonableness = 64;
VAR
    KFree,
    KNeededForReason,
    WorstCondition,
    Condition       : CARDINAL;
    Class           : APageClass;
    ClassStatus     : APageClassStatus;
(*DOS>*)
BEGIN
(*<DOS*)
    KNeededForReason := DesiredFreeKForReasonableness;

    IF (Interlock > 0) THEN
        WorstCondition := 2;     (* Reentrancy lockout. *)        (* 25-Sep-89 LAA *)
    ELSE
        WorstCondition := 0;
    END; 
    FOR Class := PageFast TO PageSlow DO
        IF (ClassPageSize[Class] > 0) THEN
            PageClassStatus(Class,ClassStatus);
            Condition := ClassStatus.Condition;
            IF (Condition > WorstCondition) THEN
                WorstCondition := Condition;
            END;
            IF (Class <> PageFast) THEN
                KFree := ClassStatus.FreePages * (ClassPageSize[Class] DIV 1024);
                IF (KNeededForReason > KFree) THEN
                    DEC( KNeededForReason, KFree );
                ELSE
                    KNeededForReason := 0;
                END;
            END;
        END;
    END;

    (* 21-Aug-89 RSC  If there is not enough free space to satisfy us,
                      then make us queazy.
    *)
    IF (WorstCondition = 0) AND
       (KNeededForReason > 0) THEN
        WorstCondition := 1;
    END;

    RETURN VAL(AnExtStatus,WorstCondition);
(*DOS>*)

(*<OS2
    RETURN ExtGood;
OS2>*)
END GetExtStatus;










PROCEDURE InitFlexStor();
VAR
    InitIndex          : CARDINAL;
(*<DOS*)
    Class              : APageClass;
(*DOS>*)
BEGIN
        (* Initialize the FlexData module before using it. *)
    InitFlexData();

(*<DOS*)

       (* Our calculations of array sizes assume that the compiler
          pads array elements to start on an even offset boundary. *)
    IF (TSIZE(TwoOddSizedRecords) <> (TSIZE(AnOddSizedRecord)+1)*2 ) THEN
        StorageError();
    END;

    Quantity  := 0;
    Interlock := 0; 
(*DOS>*)
    FOR InitIndex := 1 TO MaxPages DO
        PageTable^[InitIndex].Valid := FALSE;
    END;

(*<DOS*)
    FOR InitIndex := 0 TO ORD(HIGH(CellBlockTable)) DO
        CellBlockTable[CHR(InitIndex)] := NIL;
    END;

    TopCellBlock := 0C;
    IF (NOT CreateCellBlock(0C)) THEN StorageError(); END;

    FOR Class := PageFast TO PageSlow DO
        ClassPageSize[ Class ] := 0;
        LastPageAdded[ Class ] := 1;
        LotFSET + A.SEGMENT) MOD HashTableSize;
END Hash;

(*$S=*) (*$R=*) (*T=*)


PROCEDURE Search(     TheHandle : AnExtHandle;
                  VAR HashTableIndex : CARDINAL;
                  VAR HashRecordIndex : CARDINAL  ) : BOOLEAN;
BEGIN
    HashTableIndex := Hash(TheHandle);
        (* Get the top of the chain. *)
    HashRecordIndex := HashTable[ HashTableIndex ];
        (* Search the chain for the record with the Handle in it. *)
    WHILE (HashR